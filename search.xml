<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序swiper组件用箭头控制无法衔接]]></title>
    <url>%2F2019%2F04%2F10%2F19-04%2F19-4-10%2F</url>
    <content type="text"><![CDATA[问题描述小程序组件swiper左右滑动，自动轮播时circular衔接效果都是没有问题的，但当我们用左右箭头模拟轮播的时候，衔接效果却失效了，问题出在哪里？我们来看下面一段代码：12345678910111213141516171819202122232425262728293031323334353637383940//wxml &lt;view class=&apos;swiperbox&apos;&gt; &lt;swiper class=&apos;swiper-content&apos; circular=&quot;true&quot; style=&quot;height:&#123;&#123;Height&#125;&#125;;&quot; current=&apos;&#123;&#123;current&#125;&#125;&apos; circular=&apos;true&apos; bindchange=&quot;demo&quot; autoplay=&apos;&#123;&#123;autoplay&#125;&#125;&apos; interval=&quot;&#123;&#123;interval&#125;&#125;&quot;&gt; &lt;swiper-item wx:for=&quot;&#123;&#123;swiperData&#125;&#125;&quot; wx:key=&quot;index&quot;&gt; &lt;image src=&apos;&#123;&#123;item&#125;&#125;&apos;&gt;&lt;/image&gt; &lt;view class=&apos;page&apos;&gt;&#123;&#123;index+1&#125;&#125;/&#123;&#123;swiperData.length&#125;&#125;&lt;/view&gt; &lt;/swiper-item&gt; &lt;/swiper&gt;&lt;/view&gt;&lt;view class=&apos;bottom&apos;&gt; &lt;view class=&apos;btn-left&apos; bindtap=&apos;prev&apos;&gt;&lt;image src=&apos;&#123;&#123;AppImg.pptpageleft&#125;&#125;&apos;&gt;&lt;/image&gt;&lt;/view&gt; &lt;view class=&apos;btn-right&apos; bindtap=&apos;next&apos;&gt;&lt;image src=&apos;&#123;&#123;AppImg.pptpageright&#125;&#125;&apos;&gt;&lt;/image&gt;&lt;/view&gt;&lt;/view&gt;//js data: &#123; AppImg: util.AppImg, Height: &apos;530rpx&apos;, swiperData:[ &apos;../img/demo.png&apos;, &apos;../img/demo.png&apos;, &apos;../img/demo.png&apos; ], current:0, interval: 100, autoplay: false, &#125;,//下一页 next:function()&#123; let count = this.data.current count = count &lt; (this.data.swiperData.length - 1) ? count + 1 : 0; this.setData(&#123; current:count &#125;) &#125;,//current改变时触发的change事件 demo:function(e)&#123; console.log(e.detail.source) &#125;, 问题分析上面代码中，滑动时source（来源）打印的是touch，自动轮播时打印的是autoplay，但我们点击下一页时，打印的却是空，那么，我们猜测是swiper组件只内置了滑动与自动轮播的机制，没有点击下一页的机制，当我们用箭头模拟时，swiper无法在内部找到source来源，所以无法衔接滑动了，既然知道了是source的原因，那么我们要考虑的就是如何模拟swiper内部机制了，那如何去模拟呢，这就要从autoplay这个内置属性搞事情了。 思路：将autoplay默认为false，点击下一页，将autoplay重置为true，检测bindchange事件的source来源，如果是autoplay，就做动态关闭处理将其设置为false 1234567891011121314151617181920212223242526272829303132333435data: &#123; AppImg: util.AppImg, Height: &apos;530rpx&apos;, swiperData:[ &apos;../img/demo.png&apos;, &apos;../img/demo.png&apos;, &apos;../img/demo.png&apos; ], current:0, interval: 100, autoplay: false, &#125;, //上一页 prev:function()&#123; let count = this.data.current count = count&gt;0?count-1:this.data.swiperData.length-1 this.setData(&#123; current:count &#125;) &#125;, //下一页 next:function()&#123; this.setData(&#123; autoplay:true &#125;) &#125;, //当前页current改变时触发的change事件 demo:function(e)&#123; console.log(e.detail.source) if(e.detail.source==&apos;autoplay&apos;)&#123; this.setData(&#123; autoplay:false &#125;) &#125; &#125;,]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue九宫格抽奖功能]]></title>
    <url>%2F2019%2F04%2F04%2F19-04%2F19-4-4%2F</url>
    <content type="text"><![CDATA[vue九宫格抽奖页面结构12345678910111213&lt;div id=&quot;gift-box&quot;&gt; &lt;ul&gt; &lt;li :class=&quot;[index==0?&apos;active&apos;:&apos;&apos;]&quot;&gt;一等奖&lt;/li&gt; &lt;li :class=&quot;[index==1?&apos;active&apos;:&apos;&apos;]&quot;&gt;二等奖&lt;/li&gt; &lt;li :class=&quot;[index==2?&apos;active&apos;:&apos;&apos;]&quot;&gt;三等奖&lt;/li&gt; &lt;li :class=&quot;[index==3?&apos;active&apos;:&apos;&apos;]&quot;&gt;四等奖&lt;/li&gt; &lt;a :class=&quot;&#123;cur:curshow&#125;&quot; @click=&quot;startRoll&quot;&gt;开始&lt;/a&gt; &lt;li :class=&quot;[index==4?&apos;active&apos;:&apos;&apos;]&quot;&gt;五等奖&lt;/li&gt; &lt;li :class=&quot;[index==5?&apos;active&apos;:&apos;&apos;]&quot;&gt;六等奖&lt;/li&gt; &lt;li :class=&quot;[index==6?&apos;active&apos;:&apos;&apos;]&quot;&gt;七等奖&lt;/li&gt; &lt;li :class=&quot;[index==7?&apos;active&apos;:&apos;&apos;]&quot;&gt;八等奖&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 样式1234567*&#123;margin:0;padding:0;&#125;#gift-box&#123;width:310px;height:310px;margin:30px auto;&#125;ul&#123;width:310px;height:310px;list-style:none;&#125;ul li,ul a&#123;width:100px;height:100px;border:1px solid #565656;float:left;text-align:center;line-height:100px;&#125;ul a:hover&#123;cursor:pointer;color:orange;font-size:18px;&#125;ul .active&#123;background:red;color:#fff;&#125;.cur &#123;background-color: #ccc;&#125; 思路：点击开始抽奖，调用转动的方法，如果达到转动次数要求，且转到中奖位置，则停止，否则继续抽奖 js 123456789101112131415161718192021222324252627282930313233343536373839404142434445data()&#123; return&#123; index: -1,// 当前转动到哪个位置，起点位置 count: 8,//总共有多少位置 timer: 0,//每次转动定时器 speed: 200,//初始转动速度 times: 0,// 转动次数 cycle: 3,//转动基数：至少需要转动多少次再进入抽奖环节 prize: 5,//中奖位置 &#125;&#125;,methods:&#123; // 开始抽奖 startRoll:function()&#123; this.times+=1//转动次数 this.oneRoll()// 转动过程调用的每一次转动方法，这里是第一次调用初始化 this.usePrize() &#125;, // 转动的方法 oneRoll:function()&#123; let index = this.index //当前转动到的位置 const count = 8 //总共的位置 index += 1 if(index &gt;count - 1)&#123; index = 0 &#125; this.index = index &#125;, //判断是否转到中奖位置，如果是，停止，如果不是，继续转动 usePrize:function()&#123; // 判断是否达到转动次数要求且转到的位置是中奖位置 if(this.times &gt; this.cycle + 10 &amp;&amp; this.prize === this.index) &#123; clearTimeout(this.timer) //清除定时器，转动停止 this.times = 0 this.giftopen = true //显示开奖界面 // alert(&apos;恭喜你，中奖了&apos;) &#125;else &#123; //否则继续转动 if(this.times&lt;this.cycle)&#123; this.speed-=5 &#125; this.timer = setTimeout(this.startRoll, this.speed) &#125; &#125;&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中引入iconfont]]></title>
    <url>%2F2019%2F04%2F03%2F19-04%2F19-4-3%2F</url>
    <content type="text"><![CDATA[vue中引入iconfont 打开 iconFont官网 选择自己喜欢的图标，并且添加购物车 将选好的图标下载到本地,并复制到assets目录下 在main.js中引入文件中的iconfont.css文件 1import &apos;./assets/iconfont/iconfont.css&apos; 然后就可以用啦 1&lt;p id=&quot;pp&quot;&gt;&lt;i class=&quot;iconfont icon-tongzhigonggao&quot;&gt;&lt;/i&gt;666&lt;/p&gt; 注意：如果没有下载css-loader依赖包，可能会报如下错误，需要下载一下npm install css-loader –save123456These relative modules were not found:* ./iconfont.eot?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css* ./iconfont.svg?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css* ./iconfont.ttf?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css* ./iconfont.woff?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP 解决跨越问题]]></title>
    <url>%2F2019%2F03%2F29%2F19-03%2F2019-3-29%2F</url>
    <content type="text"><![CDATA[ThinkPHP 解决跨越问题 首先在 application目录下的tags.php中找到 app_init，并将其修改为下面的样子1234注册解决跨域的类: &apos;app_init&apos; =&gt; [ &apos;app\\index\\behavior\\CORS&apos; ], 在application-&gt;index目录下新建behavior文件夹-&gt;CORS.php，将下面这段代码复制进去123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm. * User: Gaoy * Date: 2017/12/22 * Time: 16:13 */namespace app\index\behavior;use think\Response;class CORS &#123; public function appInit()&#123; header(&apos;Access-Control-Allow-Origin: *&apos;); header(&quot;Access-Control-Allow-Headers: token, Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;); header(&apos;Access-Control-Allow-Methods: POST,GET,PUT,DELETE&apos;); if(request()-&gt;isOptions())&#123; exit(); &#125; &#125;&#125; ╮(╯▽╰)╭ 大工告成，果然还是后台来做跨越简单，jsonp什么的果然弱到爆。。。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 多项选择功能]]></title>
    <url>%2F2019%2F03%2F28%2F19-03%2F2019-3-28%2F</url>
    <content type="text"><![CDATA[多项选择 同时可以选中多个， 多选已选中状态再次点击取消选中 多选选中项的记录，选择几个记录几个，选中再取消时需要将本条记录的数据同时消除 结构123456789&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;h3&gt;问题：&lt;/h3&gt; &lt;ul&gt; &lt;li :class=&quot;&#123;cur:arr.indexOf(item.id)&gt;-1&#125;&quot; @click=&quot;addcur(item.id)&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; ref=&quot;liId&quot;&gt;&#123;&#123;item.txt&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;btn&quot; @click=&quot;nextquestion&quot;&gt;下一题&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 数据123456789101112data()&#123; return &#123; list:[ &#123;id:1,txt:&apos;a第1个&apos;&#125;, &#123;id:2,txt:&apos;b第2个&apos;&#125;, &#123;id:3,txt:&apos;c第3个&apos;&#125;, &#123;id:4,txt:&apos;d第4个&apos;&#125;, ], arr:[], str:&apos;&apos; &#125; &#125;, js选中思路：新建一个数组，判断当前点击元素的id有没有在数组中存在。如果有就删除掉这个id，如果没有，就添加到数组中选中状态：判断点击元素的id是否在新数组中，如果新数组arr中有这个元素的id，就添加选中的类，如果没有就不添加 1234567891011121314addcur:function(id)&#123; let indexd = this.arr.indexOf(id)//点击元素所在的下标 // 判断数组中是否有点击元素的id，如果有删除掉，如果没有则添加 if(indexd&gt;-1)&#123; this.arr.splice(indexd,1) &#125;else &#123; this.arr.push(id) &#125; // console.log(this.arr.join(&quot;&quot;)) console.log(this.arr) &#125;,]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call()和apply()区别]]></title>
    <url>%2F2019%2F03%2F27%2F19-03%2F2019-3-27%2F</url>
    <content type="text"><![CDATA[定义apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。 call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。 语法12345/*apply()方法*/function.apply(thisObj[, argArray])/*call()方法*/function.call(thisObj[, arg1[, arg2[, [,...argN]]]]); 作用改变执行上下文 什么是执行上下文我们在写一个方法的时候，总是会用到一个关键字this，而this的指向就是我们这里所说的执行上下文（执行环境） this指向的永远是调用该方法的对象12345function test1()&#123; this.num = 1 console.log(this.num) &#125;test1()//1 上面代码中的test1是全局对象window下的一个方法，那么调用该方法的对象就是全局对象window，所以this的指向对象就应该是window，所以上面打印结果为1在知道什么是执行上下文后，那么改变执行上下文的含义就更好理解了（函数被调用的时候, 查看this 指向哪个object, 那么那个object 就是当前的 “上下文”。按照江湖流传的说法，就是改变this指向） 改变执行上下文的意义嗯~简单来说，就是为了方便，举个栗子：大壮有一个电热锅，大壮的小伙伴二狗子今天想吃火锅，但二狗子没有电热锅，他又不想为吃一顿火锅再去买个电热锅，于是就借用了大壮的电热锅，这样既可以达到目的，又节省了开支，一举两得 改变执行上下文也是一样，A对象有一个方法，而B对象因为某种原因也需要用到一样的方法，那么这时候我们去借用A的方法远比再给B扩展一个同样的方法来的要划算，既可以完成需求，又能减少内存的占用，何乐而不为 异同 相同点：都能够改变方法的执行上下文（执行环境），将一个对象的方法交给另一个对象来执行，并且是立即执行 不同点call方法从第二个参数开始可以接收任意个参数，每个参数会映射到相应位置的func的参数上，可以通过参数名调用，但是如果将所有的参数作为数组传入，它们会作为一个整体映射到func对应的第一个参数上，之后参数都为空 1234567function test (a,b,c) &#123;&#125;test.call(obj, 1,2,3)// function接收到的参数实际上是 1,2,3test.call(obj, [1,2,3])// function接收到的参数实际上是 [1,2,3],undefined,undefined apply方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入test中，并且会被映射到test对应的参数上12345678910test.apply(obj, [1,2,3])// function接收到的参数实际上是 1,2,3test.apply(obj, &#123; 0: 1, 1: 2, 2: 3, length: 3&#125;)// function接收到的参数实际上是 1,2,3 用途:对象继承123456789101112function parent()&#123; this.num = 1 this.sun = function()&#123; console.log(this.num+1) &#125;&#125;function son()&#123; parent.call(this)//将this指向parent函数，继承parent内的方法和变量 this.sun()&#125;son()//2 son通过call方法，继承了parent的sun方法和num变量，同时son还可以扩展自己的其他方法12345678910function son()&#123; parent.call(this)//将this指向parent函数，继承parent内的方法和变量 this.sun() this.p = 5 this.fox = function()&#123;//son自己的方法 console.log(this.p+3) &#125; fox() &#125; son()//2 8]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this关键字指向]]></title>
    <url>%2F2019%2F03%2F25%2F19-03%2F2019-3-25%2F</url>
    <content type="text"><![CDATA[最近看了一篇掘金上关于this的文章，感觉写的很好，在此记录一下，方便日后查看传送门@前端小姐姐 this是什么this是什么？首先记住this不是指向自身！this 就是一个指针，指向调用函数的对象 this的绑定规则 默认绑定 隐式绑定 硬绑定 new绑定 默认绑定默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。12345function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var name = &apos;YvetteLau&apos;;sayHi(); 在调用Hi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。上面的代码，如果在浏览器环境中运行，那么结果就是 Hello,YvetteLau但是如果在node环境中运行，结果就是 Hello,undefined.这是因为node中name并不是挂在全局对象上的。本文中，如不特殊说明，默认为浏览器环境执行结果。 隐式绑定函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun().我们来看一段代码：123456789function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person = &#123; name: &apos;YvetteLau&apos;, sayHi: sayHi&#125;var name = &apos;Wiliam&apos;;person.sayHi(); 打印的结果是 Hello,YvetteLau.sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person）需要注意的是：对象属性链中只有最后一层会影响到调用位置。123456789101112function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person2 = &#123; name: &apos;Christina&apos;, sayHi: sayHi&#125;var person1 = &#123; name: &apos;YvetteLau&apos;, friend: person2&#125;person1.friend.sayHi(); 因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend。 隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此).12345678910function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person = &#123; name: &apos;YvetteLau&apos;, sayHi: sayHi&#125;var name = &apos;Wiliam&apos;;var Hi = person.sayHi;Hi(); 结果是: Hello,Wiliam.这是为什么呢，Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢继续这个格式:XXX.fn();fn()前如果什么都没有，那么肯定不是隐式绑定，但是也不一定就是默认绑定，这里有点小疑问，我们后来会说到。除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:123456789101112131415161718192021function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person1 = &#123; name: &apos;YvetteLau&apos;, sayHi: function()&#123; setTimeout(function()&#123; console.log(&apos;Hello,&apos;,this.name); &#125;) &#125;&#125;var person2 = &#123; name: &apos;Christina&apos;, sayHi: sayHi&#125;var name=&apos;Wiliam&apos;;person1.sayHi();setTimeout(person2.sayHi,100);setTimeout(function()&#123; person2.sayHi();&#125;,200); 结果为：123Hello, WiliamHello, WiliamHello, Christina 第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象 第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why?其实这里我们可以这样理解: setTimeout(fn,delay){ fn(); },相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。 第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系 显式绑定显式绑定比较好理解，就是通过call,apply,bind的方式，显式的指定this所指向的对象。(注意:《你不知道的Javascript》中将bind单独作为了硬绑定讲解了)call,apply和bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。12345678910function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person = &#123; name: &apos;YvetteLau&apos;, sayHi: sayHi&#125;var name = &apos;Wiliam&apos;;var Hi = person.sayHi;Hi.call(person); //Hi.apply(person) 输出的结果为: Hello, YvetteLau. 因为使用硬绑定明确将this绑定在了person上。 那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看 123456789101112function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person = &#123; name: &apos;YvetteLau&apos;, sayHi: sayHi&#125;var name = &apos;Wiliam&apos;;var Hi = function(fn) &#123; fn();&#125;Hi.call(person, person.sayHi); 输出的结果是 Hello, Wiliam. 原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，隐式绑定也丢了)，没有指定this的值，对应的是默认绑定。现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它硬绑定。123456789101112function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person = &#123; name: &apos;YvetteLau&apos;, sayHi: sayHi&#125;var name = &apos;Wiliam&apos;;var Hi = function(fn) &#123; fn.call(this);&#125;Hi.call(person, person.sayHi); 此时，输出的结果为: Hello, YvetteLau，因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象 new 绑定javaScript和Ｃ＋＋不一样，并没有类，在javaScript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。1使用new来调用函数，会自动执行下面的操作： 创建一个新对象 将构造函数的作用域赋值给新对象，即this指向这个新对象 执行构造函数中的代码 返回新对象因此，我们使用new来调用函数的时候，就会新对象绑定到这个函数的this上 123456function sayHi(name)&#123; this.name = name; &#125;var Hi = new sayHi(&apos;Yevtte&apos;);console.log(&apos;Hello,&apos;, Hi.name); 输出结果为 Hello, Yevtte, 原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上 绑定优先级我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为:new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定这个规则时如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可 绑定例外凡事都有例外，this的规则也是这样。 如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind,这些值在调用时会被忽略，实际应用的是默认绑定规则123456789101112function sayHi()&#123; console.log(&apos;Hello,&apos;, this.name);&#125;var person = &#123; name: &apos;YvetteLau&apos;, sayHi: sayHi&#125;var name = &apos;Wiliam&apos;;var Hi = function(fn) &#123; fn();&#125;Hi.call(null, person.sayHi); 输出的结果是 Hello, Wiliam，因为这时实际应用的是默认绑定规则。 箭头函数箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点:（1）函数体内的this对象，继承的是外层代码块的this。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。（5）箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向 总结如何判断this的指向 函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。 函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。 函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo() 如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。 如果把Null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 如果是箭头函数，箭头函数的this继承的是外层代码块的this。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2019%2F03%2F22%2F19-03%2Fweb-2%2F</url>
    <content type="text"><![CDATA[概念：闭包是函数和声明该函数的词法环境的组合。对于闭包的定义大都比较抽象，而我的理解是：闭包就是能够读取其他函数内部变量的函数。由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁 闭包的形式 函数作为返回值12345678function lazy_sum(arr) &#123; var sum = function () &#123; return arr.reduce(function (x, y) &#123; return x + y; &#125;); &#125; return sum;&#125; 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数1var f = lazy_sum([1, 2, 3, 4, 5]); // function sum() 用函数f时，才真正计算求和的结果：1f(); // 15 在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。 请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：123var f1 = lazy_sum([1, 2, 3, 4, 5]);var f2 = lazy_sum([1, 2, 3, 4, 5]);f1 === f2; // false f1()和f2()的调用结果互不影响。 闭包注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用（可理解为：当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量） 另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：1234567891011121314function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push(function () &#123; return i * i; &#125;); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2] 在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是123f1(); // 16f2(); // 16f3(); // 16 全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量 如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：1234567891011121314151617181920function count() &#123; var arr = []; for (var i=1; i&lt;=3; i++) &#123; arr.push((function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i)); &#125; return arr;&#125;var results = count();var f1 = results[0];var f2 = results[1];var f3 = results[2];f1(); // 1f2(); // 4f3(); // 9 说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？ 当然不是！闭包有非常强大的功能。举个栗子： 在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。 在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器： 12345678910function create_counter(initial) &#123; var x = initial || 0; return &#123; inc: function () &#123; x += 1; return x; &#125; &#125;&#125; 它用起来像这样：123456789var c1 = create_counter();c1.inc(); // 1c1.inc(); // 2c1.inc(); // 3var c2 = create_counter(10);c2.inc(); // 11c2.inc(); // 12c2.inc(); // 13 在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来 闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：12345function make_pow(n) &#123; return function (x) &#123; return Math.pow(x, n); &#125;&#125; // 创建两个新函数: var pow2 = make_pow(2); var pow3 = make_pow(3); console.log(pow2(5)); // 25 console.log(pow3(7)); // 343]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断设备类型]]></title>
    <url>%2F2019%2F03%2F19%2F19-03%2Fweb-1%2F</url>
    <content type="text"><![CDATA[判断iPhone X1234567891011121314151617181920// 判断iPhone Xfunction isIphoneX()&#123; return /iphone/gi.test(navigator.userAgent)&amp;&amp;(screen.height == 812 &amp;&amp; screen.width==375)&#125;$(function()&#123; if(isIphoneX())&#123; $(&apos;html&apos;).addClass(&apos;iphonex&apos;) &#125;&#125;)如果只是改变样式,在.iPhone X类名下接着写类名+样式即可.iphonex .wp .middle .middle_text &#123; padding-top: 8.925rem;&#125;.iphonex .s2_content &#123; margin-top: 14.875rem;&#125; 判断iOS或安卓12345678910111213//判断iOS或安卓$(function () &#123; var u = navigator.userAgent, app = navigator.appVersion; var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1; //g var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端 if (isAndroid) &#123; alert(&quot;安卓机！&quot;) &#125; if (isIOS) &#123; alert(&quot;苹果果机！&quot;) &#125;&#125;); 判断PC端与WAP端12345678910111213141516171819202122var mobile_bs = &#123; versions: function() &#123; var u = navigator.userAgent; return &#123; trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 mobile: !! u.match(/AppleWebKit.*Mobile.*/) || !! u.match(/AppleWebKit/) &amp;&amp; u.indexOf(&apos;QIHU&apos;) &amp;&amp; u.indexOf(&apos;QIHU&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;Chrome&apos;) &lt; 0, //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或者uc浏览器 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;Mac&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部 &#125; &#125; ()&#125;;if (mobile_bs.versions.mobile) &#123; if (mobile_bs.versions.android || mobile_bs.versions.iPhone || mobile_bs.versions.iPad || mobile_bs.versions.ios) &#123; window.location.href = &quot;移动端网址&quot;; &#125;&#125;; js判断当前页面在移动设备还是在PC端中打开//js判断当前页面在移动设备还是在PC端中打开 12345678910111213141516171819202122232425262728293031323334353637383940var browser = &#123; versions: function () &#123; var u = navigator.userAgent, app = navigator.appVersion; return &#123; //移动终端浏览器版本信息 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或uc浏览器 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部 &#125;; &#125;(), language: (navigator.browserLanguage || navigator.language).toLowerCase() &#125; if (browser.versions.mobile) &#123;//判断是否是移动设备打开。browser代码在下面 var ua = navigator.userAgent.toLowerCase();//获取判断用的对象 if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123; //在微信中打开 setInterval(WeixinJSBridge.call(&apos;closeWindow&apos;),2000); &#125; if (ua.match(/WeiBo/i) == &quot;weibo&quot;) &#123; //在新浪微博客户端打开 &#125; if (ua.match(/QQ/i) == &quot;qq&quot;) &#123; //在QQ空间打开 &#125; if (browser.versions.ios) &#123; //是否在IOS浏览器打开 &#125; if(browser.versions.android)&#123; //是否在安卓浏览器打开 &#125; &#125; else &#123; //否则就是PC浏览器打开 window.close(); &#125; js判断是否为电脑端123456789101112131415161718//js判断是否为电脑端//如果返回的是false说明当前操作系统是手机端，如果返回的是true则说明当前的操作系统是电脑端function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常见数组的方法及高阶函数]]></title>
    <url>%2F2019%2F03%2F18%2F19-03%2Fweb%2F</url>
    <content type="text"><![CDATA[forEach的用法 一般数据遍历方法 1234var array = [1,2,3,4,5,6,7]; for (var i = 0; i &lt; array.length; i) &#123; console.log(i,array[i]); &#125; for in 方法遍历数组123for(let index in array) &#123; console.log(index,array[index]); &#125;; forEach 方法遍历数组123array.forEach（function(v,i,arr)&#123; console.log(v); &#125;); 语法：array.forEach(function(v, i, arr), thisValue)上述代码中第一个参数v代表当前元素，第二个参数i代表当前元素的索引（可选），第三个参数arr代表当前元素所属的数组对象（可选） thisValue 可选。传递给函数的值一般用 “this” 值。如果这个参数为空， “undefined” 会传递给 “this” 值 特点： forEach() 方法对数组的每个元素执行一次提供的函数。总是返回undefined； forEach() 方法会改变原数组 123456789 var array1 = [1,2,3,4,5]; varp = array1.forEach(function(value,index)&#123; console.log(value); //可遍历到所有数组元素 return value + 10&#125;);console.log(p); //undefined 无论怎样，总返回undefined map 方法语法：和forEach一样array.map(function(currentValue,index,arr), thisValue)第一个参数v代表当前元素，第二个参数i代表当前元素的索引（可选），第三个参数arr代表当前元素所属的数组对象（可选）1234567var p1 = array1.map(function(value,index)&#123; console.log(value); //可遍历到所有数组元素 return value + 10&#125;);console.log(p1); //[11, 12, 13, 14, 15] 返回一个新的数组 不同于forEach的是：map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。 map() 方法按照原始数组元素顺序依次处理元素。 注意： map() 不会对空数组进行检测。 注意： map() 不会改变原始数组。 filterfilter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。123456//例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：var arr = [1, 2, 4, 5, 6, 9, 10, 15];var r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15],返回满足过滤条件元素的数组 filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：123456789101112131415161718var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];var r = arr.filter(function (element, index, self) &#123; console.log(element); // 依次打印&apos;A&apos;, &apos;B&apos;, &apos;C&apos; console.log(index); // 依次打印0, 1, 2 console.log(self); // self就是变量arr return true;&#125;);//利用filter，可以巧妙地去除Array的重复元素：var p, arr = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;orange&apos;, &apos;strawberry&apos;]; p = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;);alert(p.toString());//去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。 sort排序算法数组的sort()方法默认把所有元素先转换为String再排序，比如’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。如果使用sort()方法的默认排序规则，直接对数字排序，结果肯定是错误的，但sort()方法也是一个高阶函数，它可以接收一个比较函数来实现自定义的排序123456789101112131415161718192021222324252627282930313233//升序排列：var arr = [10, 20, 30, 1, 2, 3];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;); // [1, 2, 3, 10, 20, 30]//降序排列：var arr = [10, 20, 30, 1, 2, 3];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return 1; &#125; if (x &gt; y) &#123; return -1; &#125; return 0;&#125;); // [30, 20, 10, 3, 2, 1]//sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：var a1 = [&apos;B&apos;, &apos;A&apos;, &apos;C&apos;];var a2 = a1.sort();a1; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]a2; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]a1 === a2; // true, a1和a2是同一对象 every()定义和用法every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。 every() 方法使用指定函数检测数组中的所有元素： 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。如果所有元素都满足条件，则返回 true 注意： every() 不会对空数组进行检测。 注意： every() 不会改变原始数组。 语法：array.every(function(currentValue,index,arr), thisValue)currentValue （必须。当前元素的值）index （可选。当前元素的索引值）arr （可选。当前元素属于的数组对象）thisValue （可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”）返回值：布尔值。如果所有元素都通过检测返回 true，否则返回 false。12345678//检测数组内所有元素是否大于10function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true some()定义和用法some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。 some() 方法会依次执行数组的每个元素： 如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。注意： some() 不会对空数组进行检测。 注意： some() 不会改变原始数组。 语法：array.some(function(currentValue,index,arr),thisValue) 形式与every相同 返回值：布尔值。如果数组中有元素满足条件返回 true，否则返回 false。12345678//检测数组中是否有大于10的元素function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise对象]]></title>
    <url>%2F2019%2F03%2F14%2Fes6-7%2F</url>
    <content type="text"><![CDATA[参考自阮老师的ES6入门教程传送门 Promise用法Promise是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。 1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); resolve(&apos;返回的数据&apos;); &#125;, 2000);&#125;); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。 运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如： 1234567891011function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); resolve(&apos;返回的数据&apos;); &#125;, 2000); &#125;); return p; &#125;runAsync() Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。12345runAsync().then(function(data)&#123; console.log(data);//返回的数据 //后面可以用传过来的数据做些其他操作 //......&#125;); 在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“返回的数据”也就是说then里面的函数就跟我们平时的回调函数一个意思（then(function(data)里面的data就是runAsync()成功后返回的数据） 链式调用实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。常用于封装请求函数等场景：12345678910111213141516// 导出一个fetch函数，用来发送请求获取数据 module.exports = function (url, data) &#123; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: `https://locally.xiao.com/$&#123;url&#125;`, // 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 // 模板字符串中嵌入变量，需要将变量名写在$&#123;&#125;之中。 data, success: resolve, // success: function (res) &#123; // resolve(res) // &#125;, fail: reject &#125;) &#125;)&#125; 调用导出的函数：123456fetch(&apos;slides&apos;) .then(res =&gt; &#123; this.setData(&#123; list: res.data &#125;) &#125;) reject的用法上面用了resolve，接下来开始reject，事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。123456789101112131415161718192021222324252627function getNumber(num)&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*9); //生成1-9的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 2000); &#125;); return p; &#125;getNumber().then( function(data)&#123; console.log(&apos;resolved&apos;); console.log(data); &#125;, function(reason, data)&#123; console.log(&apos;rejected&apos;); console.log(reason); &#125;); getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： resolved 2 或 rejected 数字太大了 Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。123456789getNumber().then(function(data)&#123; console.log(&apos;resolved&apos;); console.log(data);&#125;).catch(function(reason)&#123; console.log(&apos;rejected&apos;); console.log(reason);&#125;); 上面代码中，fetch方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获 在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。 12345678910getNumber().then(function(data)&#123; console.log(&apos;resolved&apos;); console.log(data); console.log(numData); //此处的numData未定义&#125;).catch(function(reason)&#123; console.log(&apos;rejected&apos;); console.log(reason);&#125;); 在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到下面的结果： 也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。 all的用法Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。12345678910111213let p1 = new Promise(function(resolve, reject)&#123; console.log(&apos;p1&apos;); resolve(&apos;p1数据&apos;);&#125;let p2 = new Promise(function(resolve, reject)&#123; console.log(&apos;p2&apos;); resolve(&apos;p2数据&apos;)&#125;let p3 = new Promise(function(resolve, reject)&#123; console.log(&apos;p3&apos;); resolve(&apos;p3数据&apos;)&#125;const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。) 12345Promise.all([p1, p2, p3]).then(function(results)&#123; console.log(results);&#125;); all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：`//p1//p2//p3//[“p1数据”，”p2数据”，”p3数据”]]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础之对象的扩展]]></title>
    <url>%2F2019%2F03%2F13%2F19-03%2Fes6-5%2F</url>
    <content type="text"><![CDATA[本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下传送门 对象的扩展运算符解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。12let &#123; x, y, ...z &#125; = null; // 运行时错误let &#123; x, y, ...z &#125; = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。12let &#123; ...x, y, z &#125; = someObject; // 句法错误let &#123; x, ...y, ...z &#125; = someObject; // 句法错误 上面代码中，解构赋值不是最后一个参数，所以会报错 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 扩展运算符对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。123let foo = &#123; ...[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;;foo// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125; 如果扩展运算符后面不是对象，则会自动将其转为对象12// 等同于 &#123;...Object(1)&#125;&#123;...1&#125; // &#123;&#125; 上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。 但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象12&#123;...&apos;hello&apos;&#125;// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础之set数据结构]]></title>
    <url>%2F2019%2F03%2F12%2F19-03%2Fes6-6%2F</url>
    <content type="text"><![CDATA[本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下传送门 基本用法ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值Set本身是一个构造函数，用来生成 Set 数据结构 12345678const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。 Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化12345678910111213141516171819// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll(&apos;div&apos;));set.size // 56// 类似于const set = new Set();document .querySelectorAll(&apos;div&apos;) .forEach(div =&gt; set.add(div));set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 上面代码也展示了一种去除数组重复成员的方法 12// 去除数组的重复成员[...new Set(array)] 上面的方法也可以用于，去除字符串里面的重复字符12[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;)// &quot;abc&quot; 向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 123456let set = new Set();let a = NaN;let b = NaN;set.add(a);set.add(b);set // Set &#123;NaN&#125; 上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。 另外，两个对象总是不相等的1234567let set = new Set();set.add(&#123;&#125;);set.size // 1set.add(&#123;&#125;);set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set 实例的属性和方法Set 结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。Set.prototype.size：返回Set实例的成员总数。Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回 Set 结构本身。delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。has(value)：返回一个布尔值，表示该值是否为Set的成员。clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下。1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 12345678910111213141516171819// 对象的写法const properties = &#123; &apos;width&apos;: 1, &apos;height&apos;: 1&#125;;if (properties[someName]) &#123; // do something&#125;// Set的写法const properties = new Set();properties.add(&apos;width&apos;);properties.add(&apos;height&apos;);if (properties.has(someName)) &#123; // do something&#125; Array.from方法可以将 Set 结构转为数组。12const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。12345function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set 结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器values()：返回键值的遍历器entries()：返回键值对的遍历器forEach()：使用回调函数遍历每个成员 （1）keys()，values()，entries()keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。12345678910111213141516171819202122let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [&quot;red&quot;, &quot;red&quot;]// [&quot;green&quot;, &quot;green&quot;]// [&quot;blue&quot;, &quot;blue&quot;] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等 Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。12Set.prototype[Symbol.iterator] === Set.prototype.values// true 这意味着，可以省略values方法，直接用for…of循环遍历 Set。 12345678let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);for (let x of set) &#123; console.log(x);&#125;// red// green// blue （2）forEach() Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。12345let set = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))// 1 : 1// 4 : 4// 9 : 9 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。 （3）遍历的应用 扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。 123let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);let arr = [...set];// [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;] 扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。123let arr = [3, 5, 2, 2, 5, 5];let unique = [...new Set(arr)];// [3, 5, 2] 而且，数组的map和filter方法也可以间接用于 Set 了。1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference） 1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。123456789// 方法一let set = new Set([1, 2, 3]);set = new Set([...set].map(val =&gt; val * 2));// set的值是2, 4, 6// 方法二let set = new Set([1, 2, 3]);set = new Set(Array.from(set, val =&gt; val * 2));// set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础之数组的扩展]]></title>
    <url>%2F2019%2F03%2F11%2F19-03%2Fes6-4%2F</url>
    <content type="text"><![CDATA[本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下传送门 1. 扩展运算符扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args) 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法 扩展运算符的应用 复制数组数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组12345const a1 = [1, 2];const a2 = a1;a2[0] = 2;a1 // [2, 2] 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。 合并数组 1234567891011const arr1 = [&apos;a&apos;, &apos;b&apos;];const arr2 = [&apos;c&apos;];const arr3 = [&apos;d&apos;, &apos;e&apos;];// ES5 的合并数组arr1.concat(arr2, arr3);// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 两种方法都是浅拷贝，使用的时候需要注意。 与解构赋值结合扩展运算符可以与解构赋值结合起来，用于生成数组。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = [&quot;foo&quot;];first // &quot;foo&quot;rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 字符串扩展运算符还可以将字符串转为真正的数组 12[...&apos;hello&apos;]// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 实现了 Iterator 接口的对象任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组 12let nodeList = document.querySelectorAll(&apos;div&apos;);let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）123456789101112let arrayLike = &#123; &apos;0&apos;: &apos;a&apos;, &apos;1&apos;: &apos;b&apos;, &apos;2&apos;: &apos;c&apos;, length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]// ES6的写法let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] Array.of()Array.of方法用于将一组值，转换为数组123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: &apos;John&apos;, age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 数组实例的 fill()fill方法使用给定值，填充一个数组。12345[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置12[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)// [&apos;a&apos;, 7, &apos;c&apos;] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。123456789let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);arr[0].name = &quot;Ben&quot;;arr// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。1234567891011121314151617for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(elem);&#125;// &apos;a&apos;// &apos;b&apos;for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(index, elem);&#125;// 0 &quot;a&quot;// 1 &quot;b&quot; 数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 数组实例的 flat()，flatMap()数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。12[1, 2, [3, 4]].flat()// [1, 2, 3, 4] 上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置 flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。12345[1, 2, [3, [4, 5]]].flat()// [1, 2, 3, [4, 5]][1, 2, [3, [4, 5]]].flat(2)// [1, 2, 3, 4, 5] 上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。 如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。12[1, [2, [3]]].flat(Infinity)// [1, 2, 3] 如果原数组有空位，flat()方法会跳过空位。12[1, 2, , 4, 5].flat()// [1, 2, 4, 5] flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组123// 相当于 [[2, 4], [3, 6], [4, 8]].flat()[2, 3, 4].flatMap((x) =&gt; [x, x * 2])// [2, 4, 3, 6, 4, 8] flatMap()只能展开一层数组。123// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])// [[2], [4], [6], [8]] 上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。 flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。123arr.flatMap(function callback(currentValue[, index[, array]]) &#123; // ...&#125;[, thisArg]) flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础之函数的扩展]]></title>
    <url>%2F2019%2F03%2F10%2F19-03%2Fes6-3%2F</url>
    <content type="text"><![CDATA[本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下传送门 函数参数默认值ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法12345678function log(x, y) &#123; y = y || &apos;World&apos;; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面1234567function log(x, y = &apos;World&apos;) &#123; console.log(x, y);&#125;log(&apos;Hello&apos;) // Hello Worldlog(&apos;Hello&apos;, &apos;China&apos;) // Hello Chinalog(&apos;Hello&apos;, &apos;&apos;) // Hello 注意：参数变量是默认声明的，所以不能用let或const再次声明。1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 使用参数默认值时，函数不能有同名参数。12345678910// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。 rest参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。12345// 报错let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值 注意点（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础之字符串相关扩展]]></title>
    <url>%2F2019%2F03%2F09%2F19-03%2Fes6-2%2F</url>
    <content type="text"><![CDATA[本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下传送门 字符串的遍历器接口ES6 为字符串添加了遍历器接口（Iterator接口），使得字符串可以被for…of循环遍历123456for (let num of &apos;foo&apos;) &#123; console.log(num)&#125;// &quot;f&quot;// &quot;o&quot;// &quot;o&quot; includes(), startsWith(), endsWith() 之前JavaScript 只有indexOf方法用来确定一个字符串是否包含在另一个字符串中，ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;Hello&apos;) // trues.endsWith(&apos;!&apos;) // trues.includes(&apos;o&apos;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。12345let s = &apos;Hello world!&apos;;s.startsWith(&apos;world&apos;, 6) // trues.endsWith(&apos;Hello&apos;, 5) // trues.includes(&apos;Hello&apos;, 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。123&apos;x&apos;.repeat(3) // &quot;xxx&quot;&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;&apos;na&apos;.repeat(0) // &quot;&quot; 参数如果是小数，会被取整1&apos;na&apos;.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity，会报错。1234&apos;na&apos;.repeat(Infinity)// RangeError&apos;na&apos;.repeat(-1)// RangeError 如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0参数NaN等同于 0。1&apos;na&apos;.repeat(-0.9) // &quot;&quot; 参数是字符串，则会先转换成数字12&apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot;&apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot; padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。12345&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; 上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串12&apos;xxx&apos;.padStart(2, &apos;ab&apos;) // &apos;xxx&apos;&apos;xxx&apos;.padEnd(2, &apos;ab&apos;) // &apos;xxx&apos; 如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串12&apos;abc&apos;.padStart(10, &apos;0123456789&apos;)// &apos;0123456abc&apos; 如果省略第二个参数，默认使用空格补全长度。12&apos;x&apos;.padStart(4) // &apos; x&apos;&apos;x&apos;.padEnd(4) // &apos;x &apos; padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串123&apos;1&apos;.padStart(10, &apos;0&apos;) // &quot;0000000001&quot;&apos;12&apos;.padStart(10, &apos;0&apos;) // &quot;0000000012&quot;&apos;123456&apos;.padStart(10, &apos;0&apos;) // &quot;0000123456&quot; 另一个用途是提示字符串格式。 12&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-MM-12&quot;&apos;09-12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-09-12&quot; 模板字符串传统的输出模板常为字符串拼接，这种写法相当繁琐和不简洁，ES6 引入了模板字符串解决这个问题12345$(&apos;#result&apos;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量,模板字符串中嵌入变量，需要将变量名写在${}之中。 如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$(&apos;#list&apos;).html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 所有模板字符串的空格和换行，都是被保留的，比如标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。123456$(&apos;#list&apos;).html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); ${}大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。123456`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// &quot;1 + 4 = 5&quot;let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// &quot;3&quot; 模板字符串之中还能调用函数。123456function fn() &#123; return &quot;Hello World&quot;;&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[es6基础之变量的解构赋值]]></title>
    <url>%2F2019%2F03%2F08%2F19-03%2Fes6-1%2F</url>
    <content type="text"><![CDATA[本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下传送门 数组的解构赋值概念：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值基本用法：1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值,也就是说，只要两边的模式相同，左边的变量就会对应赋为右边的值例如：123456789101112131415let [a, [[b], c]] = [1, [[2], 3]];a // 1b// 2c // 3let [ , , str] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];str // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [fir, ...sce] = [1, 2, 3, 4];fir // 1sce // [2, 3, 4] 如果解构不成功，变量的值就等于undefined。12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos; 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值 对象的解构赋值123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象解构赋值时变量必须与属性同名，才能取到正确的值数组的元素是按次序排列的，变量的取值由它的位置决定。而对象不用受位置限制 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。1234567let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者例如：123let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 解构赋值的用途 交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x];//x：2 y:1 函数返回多个值函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便 1234567891011121314function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数的定义解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取 JSON 数据 12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取 JSON 数据的值。]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo文章中插入图片问题]]></title>
    <url>%2F2019%2F03%2F04%2Fimg%2F</url>
    <content type="text"><![CDATA[hexo内本地图片直接引入无法显示问题 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在根目录下输入npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件 再运行hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片即可 如：1//![你想输入的替代文字](xxxx/图片名.jpg) hexo d 上传后就能看到图片了]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo添加live2d看板动画]]></title>
    <url>%2F2019%2F03%2F04%2Flive2d%2F</url>
    <content type="text"><![CDATA[hexo的next主题添加看板动画 git定位到根目录文件，并输入以下命令1npm install --save hexo-helper-live2d 下载各种模型：npm install + 模型名 (npm install live2d-widget-model-shizuku) 12345678910111213141516live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-niet 此时再去 node_moduels目录下，可以看到有如下文件夹，这些都是动画主配置 在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中 hexo的配置文件_config.yml中添加如下配置 1234567891011121314151617#2dlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: left width: 120 height: 240 mobile: show: false 配置博客站点配置文件，_config.yml将里面的use:换成下载的模型名称 hexo d上传后就会在右下角出现live2d动画了 取消看板动画直接运行npm uninstall hexo-helper-live2d去掉站点_config.yml下的配置信息即可 添加live2d直接引入版（这个是github上人家的api，也许会在哪天失效）不想配置的话，直接在next/layout/_layout.swig(生成主页面的文件)中引入下面文件1234//将代码加入&lt;head&gt;或&lt;body&gt;，就可以看到效果了&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 此配置来自github上大佬的资源，附上大佬的github地址这是人家的一个api，也许哪天挂了呢？如果想一直使用要拷贝到自己的服务器中，并搭建php环境，api的github地址]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex的相关使用]]></title>
    <url>%2F2019%2F03%2F01%2F19-03%2Fvuex%2F</url>
    <content type="text"><![CDATA[引入单独建一个store文件夹，用来管理store的状态12345import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import &apos;es6-promise/auto&apos;import axios from &apos;axios&apos;Vue.use(Vuex) 核心概念 store（仓库）：“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)store 中的状态不能直接修改，改变 store 中的状态的唯一途径就是显式地提交 (commit) 12345678910const state = &#123; uuid: &apos;&apos;, user: &#123;&#125;, qrCode:&apos;&apos;, qrCodeUser:&#123;&#125;, prizeQrCode:&apos;&apos;, prizeQrCodeUser:&#123;&#125;, errorMsg:&apos;&apos;,&#125;$store.commit(&apos;setQrCode&apos;,&apos;e1dddec9&apos;)//setQrCode是要修改的state内的状态，e1dddec9是修改为的数据，可以是一个对象 2.getter（可以认为是 store 的计算属性）：就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算Getter 接受 state 作为其第一个参数123456789101112131415161718192021222324252627282930313233343536373839const getters = &#123; // 将数据从cache中取出 getCache: function (state) &#123; return function (key) &#123; var cache_data = localStorage.getItem(key) if (!cache_data) &#123; return null &#125; // var data = JSON.parse(Base64.decode(cache_data)) var data = JSON.parse(cache_data) if (data.timeout === 0 || data.timeout &gt; (new Date()).getTime()) &#123; return data.data &#125; localStorage.removeItem(key) return null &#125; &#125;, getUUID: function () &#123; return state.uuid &#125;, getAdminUserInfo: function () &#123; return state.user &#125;, getQrCode:function () &#123; return state.qrCode &#125;, getQrCodeUserInfo:function () &#123; return state.qrCodeUser &#125;, getPrizeQrCode:function () &#123; return state.prizeQrCode &#125;, getPrizeQrCodeUserInfo:function () &#123; return state.prizeQrCodeUser &#125;, getErrMsg:function () &#123; return state.errorMsg &#125;&#125; 在任意组件的计算属性中可以获取getters内函数的返回值如：获取上面计算属性中的UID1234computed:&#123; uid:function () &#123; return this.$store.getters[&apos;getUUID&apos;]; &#125;, 3.Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数12345678910111213141516171819202122232425262728293031323334353637//第一个参数为state状态对象，第二个参数Payload载荷（也就是要修改为的数据）const mutations = &#123; // 将数据存储到cache中 setCache: function (state, data) &#123; if (data.timeout === undefined) &#123; data.timeout = 30 * 24 * 3600 * 1000 &#125; var obj = &#123; data: data.value, timeout: data.timeout + (new Date()).getTime() &#125; // var cache = Base64.encode(JSON.stringify(obj)); var cache = JSON.stringify(obj) localStorage.setItem(data.key, cache) &#125;, clearCache: function (state, key) &#123; localStorage.removeItem(key) &#125;, setAdminUserInfo (state, data) &#123; state.user = data &#125;, setQrCodeUserInfo(state,data)&#123; state.qrCodeUser = data; &#125;, setQrCode(state,data)&#123; state.qrCode = data; &#125;, setPrizeQrCodeUserInfo(state,data)&#123; state.prizeQrCodeUser = data; &#125;, setPrizeQrCode(state,data)&#123; state.prizeQrCode = data; &#125;, setErrMsg(state,data)&#123; state.errorMsg = data &#125;&#125; 在组件中提交 Mutation（提交载荷）在组件中使用 this.$store.commit(‘xxx’) 提交 mutation如：12345678910111213141516171819202122232425getQrcodeInfo:function (code) &#123; let self = this; this.$http(&#123; methods:&apos;get&apos;, url:&apos;/mfw/xiaoliwu/backend/Login/showCodeInfo&apos;, params:&#123; uid:this.uid, code:code &#125; &#125;).then(res=&gt;&#123; console.log(res) if(res.data.code === 0)&#123; self.$store.commit(&apos;setQrCodeUserInfo&apos;,res.data.data)//此处就是提交上面mutation内的setQrCodeUserInfo函数，这个函数的第二个参数就是上面的data this.$router.push(&#123; path:&apos;/convert&apos; &#125;) &#125;else &#123; self.$vux.alert.show(&#123; title: &apos;&apos;, content: res.data.msg, buttonText:&apos;知道了&apos; &#125;) &#125; &#125;) &#125;, ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。123456789101112131415const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // 这里的 `state` 对象是模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit(&apos;increment&apos;) &#125; &#125; &#125;&#125; 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; 导出将上面的以常量形式声明的各个核心导出，就可以在任意组件中调用了123export default new Vuex.Store(&#123; state, getters, mutations, actions&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信jssdk的接入（分享及扫码功能）]]></title>
    <url>%2F2019%2F03%2F01%2F19-03%2Fsdk%2F</url>
    <content type="text"><![CDATA[vue中使用（vux版）微信扫一扫功能分享接口只有认证公众号才能使用，域名必须备案且在微信后台设置。先确认已经满足使用jssdk的要求再进行开发。1.引入vux类库2.在 main.js 中全局引入1234import &#123; WechatPlugin &#125; from &apos;vux&apos;Vue.use(WechatPlugin)console.log(Vue.wechat) // 可以直接访问 wx 对象。 3.全局引入后就可以在任意组件内调用了，如：1234567this.$wechat.scanQRCode(&#123; needResult: 0, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果， scanType: [&quot;qrCode&quot;,&quot;barCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有 success: function (res) &#123; var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果 &#125; &#125;); 准备工作完成，下面开始正式的流程步骤一、绑定域名先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名” （这个一般是后台去做的） 步骤二、引入JS文件jquery的项目在需要调用JS接口的页面引入如下JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.4.0.jsvue的项目可以用vux的组件，就是我上面介绍的那一堆东西 步骤三、通过config接口注入权限验证配置这个过程一般都是在App.vue中完成思路：先向后台请求配置所需要的数据，也就是下面的scan()函数,得到数据后在通过config接口注入权限验证配置，也就是init()函数，最后在create生命周期中调用一下scan()函数，这一步就算完成了12345678910111213141516171819202122232425init:function(data)&#123; //通过config接口注入权限验证配置 this.$wechat.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.app_id, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature,// 必填，签名，见附录1 jsApiList: [&apos;scanQRCode&apos;] // 必填，需要使用的JS接口列表 &#125;); //通过ready接口处理成功验证 &#125;,scan:function()&#123; this.$http(&#123; methods:&apos;get&apos;, url:&apos;/gongzhonghao/Jssdk&apos;, params:&#123; // 代码需要上传服务器，否则返回为0 url:location.href.split(&apos;#&apos;)[0], &#125; &#125;).then(res=&gt;&#123; this.init(res.data.data) &#125;) &#125;, 步骤四、在需要的组件内调用功能接口，如下面调用的是扫一扫的接口123456789101112131415161718let self = this;self.$wechat.scanQRCode(&#123; needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果， scanType: [&quot;qrCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有 success: function (res) &#123; self.$vux.loading.hide(); var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果 if (result)&#123; self.$store.commit(&apos;setPrizeQrCode&apos;,result); self.getPrizeQrcodeInfo(result) &#125;else &#123; self.$vux.alert.show(&#123; content:&apos;未识别的兑换码&apos; &#125;) &#125; &#125; &#125;); 注意：微信的sdk只能在微信中打开，如果不是，则无法使用微信的功能，下面是判断是否微信打开的函数123456789101112131415isWeixn:function()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i)==&quot;micromessenger&quot;) &#123; return true; &#125; else &#123; return false; &#125; &#125;, //判断是否微信的处理 if(this.isWexin())&#123; //是微信，在里面写相关的业务逻辑，如分享，扫码等功能 &#125;else &#123; //这个是硬性不支持，没有办法的 alert(&apos;请在微信中打开&apos;) &#125; 附录：微信js-sdk说明文档 jquery中使用sdk1.在需要调用JS接口的页面引入如下JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.4.0.js 2.jssdk的签名权限,这个权限是由后台提供的,前端只需要把签名权限注入到wx.config中就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//初始化jssdk var init = function(data)&#123; //通过config接口注入权限验证配置 wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.app_id, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature,// 必填，签名，见附录1 jsApiList: [&apos;onMenuShareTimeline&apos;,&apos;onMenuShareAppMessage&apos;] // 必填，需要使用的JS接口列表 &#125;); //通过ready接口处理成功验证 wx.ready(function()&#123; //分享到朋友圈 // var local_url = $.getStorge(&apos;auth_url&apos;);// if(!local_url)&#123;// local_url = window.location.href;// &#125; var local_url = window.location.href; console.log(local_url); wx.onMenuShareTimeline(&#123; title: desc+&apos;--&apos;+title, // 分享标题 link: local_url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;http://jssdk.cloud-cy.com/wechatShopServer/&apos;+logo, // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); //分享给朋友 wx.onMenuShareAppMessage(&#123; title: title, // 分享标题 desc: desc, // 分享描述 link: local_url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;http://jssdk.cloud-cy.com/wechatShopServer/&apos;+logo, // 分享图标 type: &apos;link&apos;, // 分享类型,music、video或link，不填默认为link dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); &#125;); &#125; //获取jssdk配置 $.ajax(&#123; type:&quot;get&quot;, url:web+&quot;/Jssdk&quot;, data:&#123; url:window.location.href, url_code:account &#125;, dataType:&quot;json&quot;, success:function(data,textStatus)&#123;console.log(data); if(data.code==200)&#123; init(data.data); &#125;else&#123;// alert(&quot;连接失败，请稍后再试或联系管理员&quot;); &#125; &#125; &#125;);]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的类库vux安装]]></title>
    <url>%2F2019%2F03%2F01%2F19-03%2Fday5%2F</url>
    <content type="text"><![CDATA[##cli环境中安装vux类库 npm install vux –save 安装vux-loader （这个vux文档似乎没介绍，当初没安装结果报了一堆错误） 1npm install vux-loader --save-dev 安装less-loader （这个是用以正确编译less源码，否则会出现 ‘ Cannot GET / ‘） 1npm install less less-loader --save-dev vux2必须配合vux-loader使用, 请在build/webpack.base.conf.js里参照如下代码进行配置： const vuxLoader = require(‘vux-loader’)const webpackConfig = originalConfig 将原来的 module.exports 代码赋值给变量 webpackConfig (将原文件的module.exports改为let webpackConfig) 在文件最后一行复制下面代码 123module.exports = vuxLoader.merge(webpackConfig, &#123; plugins: [&apos;vux-ui&apos;]&#125;) 在入口文件全局引入 12import Vue from &apos;vue&apos;import &#123; XButton &#125; from &apos;vux&apos; 例：1Vue.component(&apos;x-button&apos;, XButton) 使用1&lt;x-button&gt;&lt;/x-button&gt; vux样式改变，可以在APP.vue中用样式覆盖，在组件内用scoped无法覆盖]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序基础]]></title>
    <url>%2F2019%2F02%2F28%2F19-03%2FweChat%2F</url>
    <content type="text"><![CDATA[微信小程序相关及一些小坑1.页面滑动小程序内容超出父盒子，或者页面超出屏幕都不会出现滚动条滑动，如需要滑动，要使用scroll-view组件包裹着要滑动的区域scroll-view相关配置属性 scroll-view相关 scroll-view生效需要设置高度，如果没有设置高度，滑动效果不生效 去除scroll-view默认滚动条123456789::-webkit-scrollbar&#123;width: 0;height: 0;color: transparent;&#125; 2.闭包问题请求后台api中的success函数实际是一个闭包 ， 无法直接通过this来设置setData;解决方案：1.将当前对象赋给一个新对象：let that = this2.使用箭头函数123456789101112131415161718192021onLoad: function (options) &#123; console.log(options.uselogid) wx.request(&#123; url: util.Api.getUserPrizeInfo, method: &apos;get&apos;, data: &#123; openid: app.globalData.openid, user_log_id: options.uselogid &#125;, success: (res) =&gt; &#123; // console.log(res.data) this.setData(&#123; cardData: res.data.data, qrCode: res.data.data.qrCodeUrl, uselogid: options.uselogid, status: res.data.data.status &#125;) console.log(this.data.status) &#125; &#125;)&#125; 3.背景图片问题 小程序中的背景图片写在wxss预览时无法显现 解决方案： 1.将图片转为base64格式，才能在wxss内设置 2.写行内样式，图片用网络图片，本地图片无法预览 4.路由 1.使用navigator标签导航，注意url地址不能带文件后缀 2.在js文件内注册事件跳转 wx.navigateTo跳转保留当前页面，也就是说会有返回箭头 123wx.navigateTo(&#123; url: &apos;/pages/cardDetial/cardDetial?uselogid=&apos; + e.currentTarget.dataset.uselogid, &#125;) wx.redirectTo跳转 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。123wx.redirectTo(&#123; url: &apos;/pages/superGift/superGift&apos;, &#125;) 5.页面间传值传值:和web页面差不多，也是在url地址后面拼接参数123wx.navigateTo(&#123; url: &apos;/pages/cardDetial/cardDetial?uselogid=&apos; + e.currentTarget.dataset.uselogid, &#125;) 接收：直接在生命周期onLoad里用参数接收123onLoad: function (options) &#123; console.log(options.uselogid)&#125;, 6.无法使用外部字体图标大部分情况下直接下载iconfont的压缩包，将其内的iconfont.css文件复制到一个新的wxss文件内，然后在app.wxss文件内全局引入@import “/lib/style/iconfont.wxss”;就可以在任意文件中使用了如果出现无法使用的情况，试试下面方法：1，下载font-awesome字体包 2，打开Transfonter网站，上传字体iconfont.ttf，选择base64编码 3，convert完毕后点击下载，下载得到的包中有stylesheet.css文件，打开并对照font-awesome.css中的内容进行合并base64部分，加入到微信小程序的xxx.wxss文件中进行使用 &lt;text class=&quot;iconfont icon-xxxx&quot;&gt;&lt;/text&gt; 7.setData修改数组或对象setData无法直接修改引用类型的数据，需要字符串拼接的方式保存到变量中123456var closeShow = &quot;redPacket.myClosePackect&quot;self.setData(&#123; [closeShow]: false, &#125;) 8.textarea注意事项1.bug: 微信版本 6.3.30，textarea 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。2.tip: textarea 的 blur 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 form 的 bindsubmit。3.tip: 不建议在多行文本上对用户的输入进行修改，所以 textarea 的 bindinput 处理函数并不会将返回值反映到 textarea 上。4.tip: textarea 组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。5.tip: 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 textarea 组件。6.tip: css 动画对 textarea 组件无效。 9.原生组件无法被覆盖的问题map、video、canvas、camera 等原生组件上不可被标签覆盖，如果需要覆盖，要使用cover-view标签 且只支持嵌套cover-view、cover-image]]></content>
      <categories>
        <category>小程序</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将博客搬至CSDN]]></title>
    <url>%2F2019%2F02%2F26%2Fblogchange%2F</url>
    <content type="text"><![CDATA[搬家通知地址个人博客地址已搬家到CSDN，希望大家多多支持 最近利用hexo搭了一个博客主页，之前都是混掘金，但感觉掘金上的人越来越少了，是时候踏入下一个江湖啦~]]></content>
      <tags>
        <tag>搬家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli生成vue项目]]></title>
    <url>%2F2019%2F01%2F17%2F19-03%2Ffirst%2F</url>
    <content type="text"><![CDATA[全局安装 vue-cli1.$ cnpm install –global vue-cli 如果已经安装过了就不用安装了，这里我前面的项目已经安装过了，所以直接从第二步开始 my-project为自定义项目名2.$ vue init webpack my-project 需要注意的是项目的名称不能大写，不然会报错 项目初始化时会询问一些安装项，可以根据自己的需求选择 Project name (my-project) ==&gt;项目名称（我的项目） Project description (A Vue.js project) ==&gt;项目描述一个Vue.js 项目 Author 作者（你的名字） nstall vue-router? (Y/n) ==&gt;是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）yes Use ESLint to lint your code? (Y/n) ==&gt;使用 ESLint 到你的代码？ （Y [ yes ] / N [ no ]）此处建议选no，如果不是按照ESLint风格，编译时就会报错（就是这里坑了我，找半天没发现逻辑问题） Pick an ESLint preset (Use arrow keys) ==&gt;选择一个预置ESLint（使用箭头键） Setup unit tests with Karma + Mocha? (Y/n) ==&gt;设置单元测Karma + Mocha？ （Y/ N） Setup e2e tests with Nightwatch? (Y/n) ==&gt;设置端到端测试，Nightwatch？这里需要选yes，否则会报websocket的错误 （Y/ N）Y 3.最后一步就是安心等待啦 完成后运行npm run Dev项目就运行起来啦 注： Vue取消eslint语法限制 在build/webpack.base.conf.js文件中，注释或者删除掉：module-&gt;rules中有关eslint的规则 手机预览1234&lt;!-- 手机预览vue项目 --&gt;&lt;!-- 1.找到config文件下的index.js 将dev配置中的host:&apos;localhost&apos;改为host:&apos;0.0.0.0&apos; --&gt;&lt;!-- 2.重新运行项目npm run dev --&gt;&lt;!-- 3.在浏览器地址输入：本机ip地址:项目所占端口号 如：http://192.168.1.184:8080/#/--&gt;]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git的基本使用]]></title>
    <url>%2F2019%2F01%2F17%2F19-03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[“ 很早之前便注册了github，一直没有使用，正好这次搭建blogs可以熟悉下好久没用的git，当然，我对git的理解还是很粗浅的，主要还是通过Git教程 - 廖雪峰的官方网站来学习。” git的安装就不做介绍了，都是一直下一步的操作，我们直接进入git的操作。 第一步先创建一个本地的版本库（就是一个文件夹，随便在哪建一个） 第二步 通过git init 将这个文件夹变成git可管理的厂库 进入文件夹内右击打开git bash命令行窗口 第三步此时你会发现文件夹内多了一个.git的文件，这是用来跟踪和管理版本库的。它是默认隐藏的，如果你看不到，那就需要设置一下让隐藏文件可见 到了这一步，你就可以将自己的项目文件复制进来了然后通过git status 查看当前状态 第四步、看到文件状态后，再通过git add . 将改文件下的所有目录添加到厂库，然后用git commit -m &quot;注释&quot;把项目提交到仓库。-m后面的引号内是你本次提交的注释，这个可以随便写，或者空着 第五步将Git仓库与本地仓库进行关联（这个操作只用执行一次，关联后下次可直接进行提交） git remote add origin https://github.com/langhuonan/langhuonan.github.io.git git remote add origin 后面跟的是你github的仓库地址 第六步关联好后我们就可以吧本地库的内容推送到远程仓库github上啦 git push -u origin master (第一次推送由于远程库是空的，所以要加上-u这个参数，下次再传的时候只需要git push origin master) 至此就完成了将本地项目上传到远程库的整个过程]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
</search>
