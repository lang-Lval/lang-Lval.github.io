<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo文章中插入图片问题]]></title>
    <url>%2F2019%2F03%2F04%2Fimg%2F</url>
    <content type="text"><![CDATA[hexo内本地图片直接引入无法显示问题 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在根目录下输入npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件 再运行hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片即可 如：1//![你想输入的替代文字](xxxx/图片名.jpg) hexo d上传就能看到图片了]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo添加live2d看板动画]]></title>
    <url>%2F2019%2F03%2F04%2Flive2d%2F</url>
    <content type="text"><![CDATA[hexo的next主题添加看板动画 git定位到根目录文件，并输入以下命令npm install –save hexo-helper-live2d 下载各种模型：npm install + 模型名 (npm install live2d-widget-model-shizuku) 12345678910111213141516live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-niet 此时再去 node_moduels目录下，可以看到有如下文件夹，这些都是动画主配置 在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中 hexo的配置文件_config.yml中添加如下配置 1234567891011121314151617#2dlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-shizuku display: position: left width: 120 height: 240 mobile: show: false 配置博客站点配置文件，_config.yml将里面的use:换成下载的模型名称 hexo d上传后就会在右下角出现live2d动画了 取消看板动画直接运行npm uninstall hexo-helper-live2d去掉站点_config.yml下的配置信息即可 添加live2d直接引入版（这个是github上人家的api，也许会在哪天实效）不想配置的话，直接在next/layout/_layout.swig(生成主页面的文件)中引入下面文件1234//将代码加入&lt;head&gt;或&lt;body&gt;，就可以看到效果了&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt; 此配置来自github上大佬的资源，附上大佬的github地址这是人家的一个api，也许哪天挂了呢？如果想一直使用要拷贝到自己的服务器中，并搭建php环境，api的github地址]]></content>
      <categories>
        <category>主题相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vuex的相关使用]]></title>
    <url>%2F2019%2F03%2F01%2Fvuex%2F</url>
    <content type="text"><![CDATA[引入单独建一个store文件夹，用来管理store的状态12345import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import &apos;es6-promise/auto&apos;import axios from &apos;axios&apos;Vue.use(Vuex) 核心概念 store（仓库）：“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)store 中的状态不能直接修改，改变 store 中的状态的唯一途径就是显式地提交 (commit) 12345678910const state = &#123; uuid: &apos;&apos;, user: &#123;&#125;, qrCode:&apos;&apos;, qrCodeUser:&#123;&#125;, prizeQrCode:&apos;&apos;, prizeQrCodeUser:&#123;&#125;, errorMsg:&apos;&apos;,&#125;$store.commit(&apos;setQrCode&apos;,&apos;e1dddec9&apos;)//setQrCode是要修改的state内的状态，e1dddec9是修改为的数据，可以是一个对象 2.getter（可以认为是 store 的计算属性）：就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算Getter 接受 state 作为其第一个参数123456789101112131415161718192021222324252627282930313233343536373839const getters = &#123; // 将数据从cache中取出 getCache: function (state) &#123; return function (key) &#123; var cache_data = localStorage.getItem(key) if (!cache_data) &#123; return null &#125; // var data = JSON.parse(Base64.decode(cache_data)) var data = JSON.parse(cache_data) if (data.timeout === 0 || data.timeout &gt; (new Date()).getTime()) &#123; return data.data &#125; localStorage.removeItem(key) return null &#125; &#125;, getUUID: function () &#123; return state.uuid &#125;, getAdminUserInfo: function () &#123; return state.user &#125;, getQrCode:function () &#123; return state.qrCode &#125;, getQrCodeUserInfo:function () &#123; return state.qrCodeUser &#125;, getPrizeQrCode:function () &#123; return state.prizeQrCode &#125;, getPrizeQrCodeUserInfo:function () &#123; return state.prizeQrCodeUser &#125;, getErrMsg:function () &#123; return state.errorMsg &#125;&#125; 在任意组件的计算属性中可以获取getters内函数的返回值如：获取上面计算属性中的UID1234computed:&#123; uid:function () &#123; return this.$store.getters[&apos;getUUID&apos;]; &#125;, 3.Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数12345678910111213141516171819202122232425262728293031323334353637//第一个参数为state状态对象，第二个参数Payload载荷（也就是要修改为的数据）const mutations = &#123; // 将数据存储到cache中 setCache: function (state, data) &#123; if (data.timeout === undefined) &#123; data.timeout = 30 * 24 * 3600 * 1000 &#125; var obj = &#123; data: data.value, timeout: data.timeout + (new Date()).getTime() &#125; // var cache = Base64.encode(JSON.stringify(obj)); var cache = JSON.stringify(obj) localStorage.setItem(data.key, cache) &#125;, clearCache: function (state, key) &#123; localStorage.removeItem(key) &#125;, setAdminUserInfo (state, data) &#123; state.user = data &#125;, setQrCodeUserInfo(state,data)&#123; state.qrCodeUser = data; &#125;, setQrCode(state,data)&#123; state.qrCode = data; &#125;, setPrizeQrCodeUserInfo(state,data)&#123; state.prizeQrCodeUser = data; &#125;, setPrizeQrCode(state,data)&#123; state.prizeQrCode = data; &#125;, setErrMsg(state,data)&#123; state.errorMsg = data &#125;&#125; 在组件中提交 Mutation（提交载荷）在组件中使用 this.$store.commit(‘xxx’) 提交 mutation如：12345678910111213141516171819202122232425getQrcodeInfo:function (code) &#123; let self = this; this.$http(&#123; methods:&apos;get&apos;, url:&apos;/mfw/xiaoliwu/backend/Login/showCodeInfo&apos;, params:&#123; uid:this.uid, code:code &#125; &#125;).then(res=&gt;&#123; console.log(res) if(res.data.code === 0)&#123; self.$store.commit(&apos;setQrCodeUserInfo&apos;,res.data.data)//此处就是提交上面mutation内的setQrCodeUserInfo函数，这个函数的第二个参数就是上面的data this.$router.push(&#123; path:&apos;/convert&apos; &#125;) &#125;else &#123; self.$vux.alert.show(&#123; title: &apos;&apos;, content: res.data.msg, buttonText:&apos;知道了&apos; &#125;) &#125; &#125;) &#125;, ActionAction 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 Module由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。123456789101112131415const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; // 这里的 `state` 对象是模块的局部状态 state.count++ &#125; &#125;, getters: &#123; doubleCount (state) &#123; return state.count * 2 &#125; &#125;&#125; 同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123; if ((state.count + rootState.count) % 2 === 1) &#123; commit(&apos;increment&apos;) &#125; &#125; &#125;&#125; 对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount (state, getters, rootState) &#123; return state.count + rootState.count &#125; &#125;&#125; 导出将上面的以常量形式声明的各个核心导出，就可以在任意组件中调用了123export default new Vuex.Store(&#123; state, getters, mutations, actions&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信jssdk的接入（分享及扫码功能）]]></title>
    <url>%2F2019%2F03%2F01%2Fsdk%2F</url>
    <content type="text"><![CDATA[vue中使用（vux版）微信扫一扫功能分享接口只有认证公众号才能使用，域名必须备案且在微信后台设置。先确认已经满足使用jssdk的要求再进行开发。1.引入vux类库2.在 main.js 中全局引入1234import &#123; WechatPlugin &#125; from &apos;vux&apos;Vue.use(WechatPlugin)console.log(Vue.wechat) // 可以直接访问 wx 对象。 3.全局引入后就可以在任意组件内调用了1234567891011121314151617self.$wechat.scanQRCode(&#123; needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果， scanType: [&quot;qrCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有 success: function (res) &#123; self.$vux.loading.hide(); var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果 if (result)&#123; self.$store.commit(&apos;setQrCode&apos;,result); self.getQrcodeInfo(result) &#125;else &#123; self.$vux.alert.show(&#123; content:&apos;未识别的兑换码&apos; &#125;) &#125; &#125; &#125;); 附录：微信js-sdk说明文档 jquery中使用sdk1.在需要调用JS接口的页面引入如下JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.4.0.js 2.jssdk的签名权限,这个权限是由后台提供的,前端只需要把签名权限注入到wx.config中就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//初始化jssdk var init = function(data)&#123; //通过config接口注入权限验证配置 wx.config(&#123; debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。 appId: data.app_id, // 必填，公众号的唯一标识 timestamp: data.timestamp, // 必填，生成签名的时间戳 nonceStr: data.nonceStr, // 必填，生成签名的随机串 signature: data.signature,// 必填，签名，见附录1 jsApiList: [&apos;onMenuShareTimeline&apos;,&apos;onMenuShareAppMessage&apos;] // 必填，需要使用的JS接口列表 &#125;); //通过ready接口处理成功验证 wx.ready(function()&#123; //分享到朋友圈 // var local_url = $.getStorge(&apos;auth_url&apos;);// if(!local_url)&#123;// local_url = window.location.href;// &#125; var local_url = window.location.href; console.log(local_url); wx.onMenuShareTimeline(&#123; title: desc+&apos;--&apos;+title, // 分享标题 link: local_url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;http://jssdk.cloud-cy.com/wechatShopServer/&apos;+logo, // 分享图标 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); //分享给朋友 wx.onMenuShareAppMessage(&#123; title: title, // 分享标题 desc: desc, // 分享描述 link: local_url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致 imgUrl: &apos;http://jssdk.cloud-cy.com/wechatShopServer/&apos;+logo, // 分享图标 type: &apos;link&apos;, // 分享类型,music、video或link，不填默认为link dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空 success: function () &#123; // 用户确认分享后执行的回调函数 &#125;, cancel: function () &#123; // 用户取消分享后执行的回调函数 &#125; &#125;); &#125;); &#125; //获取jssdk配置 $.ajax(&#123; type:&quot;get&quot;, url:web+&quot;/Jssdk&quot;, data:&#123; url:window.location.href, url_code:account &#125;, dataType:&quot;json&quot;, success:function(data,textStatus)&#123;console.log(data); if(data.code==200)&#123; init(data.data); &#125;else&#123;// alert(&quot;连接失败，请稍后再试或联系管理员&quot;); &#125; &#125; &#125;);]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的类库vux安装]]></title>
    <url>%2F2019%2F03%2F01%2Fday5%2F</url>
    <content type="text"><![CDATA[##cli环境中安装vux类库 1. npm install vux --save vux2必须配合vux-loader使用, 请在build/webpack.base.conf.js里参照如下代码进行配置： const vuxLoader = require(&apos;vux-loader&apos;) const webpackConfig = originalConfig 将原来的 module.exports 代码赋值给变量 webpackConfig (将原文件的module.exports改为let webpackConfig) 2.在文件最后一行复制下面代码 123module.exports = vuxLoader.merge(webpackConfig, &#123; plugins: [&apos;vux-ui&apos;]&#125;) 3. 在入口文件全局引入 12import Vue from &apos;vue&apos;import &#123; XButton &#125; from &apos;vux&apos; 例： 1Vue.component(&apos;x-button&apos;, XButton) 使用 1&lt;x-button&gt;&lt;/x-button&gt; vux样式改变，可以在APP.vue中用样式覆盖，在组件内用scoped无法覆盖]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序基础]]></title>
    <url>%2F2019%2F02%2F28%2FweChat%2F</url>
    <content type="text"><![CDATA[微信小程序相关及一些小坑1.页面滑动小程序内容超出父盒子，或者页面超出屏幕都不会出现滚动条滑动，如需要滑动，要使用scroll-view组件包裹着要滑动的区域scroll-view相关配置属性 scroll-view相关 scroll-view生效需要设置高度，如果没有设置高度，滑动效果不生效 去除scroll-view默认滚动条123456789::-webkit-scrollbar&#123;width: 0;height: 0;color: transparent;&#125; 2.闭包问题请求后台api中的success函数实际是一个闭包 ， 无法直接通过this来设置setData;解决方案：1.将当前对象赋给一个新对象：let that = this2.使用箭头函数123456789101112131415161718192021onLoad: function (options) &#123; console.log(options.uselogid) wx.request(&#123; url: util.Api.getUserPrizeInfo, method: &apos;get&apos;, data: &#123; openid: app.globalData.openid, user_log_id: options.uselogid &#125;, success: (res) =&gt; &#123; // console.log(res.data) this.setData(&#123; cardData: res.data.data, qrCode: res.data.data.qrCodeUrl, uselogid: options.uselogid, status: res.data.data.status &#125;) console.log(this.data.status) &#125; &#125;)&#125; 3.背景图片问题 小程序中的背景图片写在wxss预览时无法显现 解决方案： 1.将图片转为base64格式，才能在wxss内设置 2.写行内样式，图片用网络图片，本地图片无法预览 4.路由 1.使用navigator标签导航，注意url地址不能带文件后缀 2.在js文件内注册事件跳转 wx.navigateTo跳转保留当前页面，也就是说会有返回箭头 123wx.navigateTo(&#123; url: &apos;/pages/cardDetial/cardDetial?uselogid=&apos; + e.currentTarget.dataset.uselogid, &#125;) wx.redirectTo跳转 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。123wx.redirectTo(&#123; url: &apos;/pages/superGift/superGift&apos;, &#125;) 5.页面间传值传值:和web页面差不多，也是在url地址后面拼接参数123wx.navigateTo(&#123; url: &apos;/pages/cardDetial/cardDetial?uselogid=&apos; + e.currentTarget.dataset.uselogid, &#125;) 接收：直接在生命周期onLoad里用参数接收123onLoad: function (options) &#123; console.log(options.uselogid)&#125;, 6.无法使用外部字体图标大部分情况下直接下载iconfont的压缩包，将其内的iconfont.css文件复制到一个新的wxss文件内，然后在app.wxss文件内全局引入@import “/lib/style/iconfont.wxss”;就可以在任意文件中使用了如果出现无法使用的情况，试试下面方法：1，下载font-awesome字体包 2，打开Transfonter网站，上传字体iconfont.ttf，选择base64编码 3，convert完毕后点击下载，下载得到的包中有stylesheet.css文件，打开并对照font-awesome.css中的内容进行合并base64部分，加入到微信小程序的xxx.wxss文件中进行使用 &lt;text class=&quot;iconfont icon-xxxx&quot;&gt;&lt;/text&gt; 7.setData修改数组或对象setData无法直接修改引用类型的数据，需要字符串拼接的方式保存到变量中123456var closeShow = &quot;redPacket.myClosePackect&quot;self.setData(&#123; [closeShow]: false, &#125;) 8.textarea注意事项1.bug: 微信版本 6.3.30，textarea 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。2.tip: textarea 的 blur 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 form 的 bindsubmit。3.tip: 不建议在多行文本上对用户的输入进行修改，所以 textarea 的 bindinput 处理函数并不会将返回值反映到 textarea 上。4.tip: textarea 组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。5.tip: 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 textarea 组件。6.tip: css 动画对 textarea 组件无效。 9.原生组件无法被覆盖的问题map、video、canvas、camera 等原生组件上不可被标签覆盖，如果需要覆盖，要使用cover-view标签 且只支持嵌套cover-view、cover-image]]></content>
      <categories>
        <category>weChat</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[将博客搬至CSDN]]></title>
    <url>%2F2019%2F02%2F26%2Fblogchange%2F</url>
    <content type="text"><![CDATA[搬家通知地址个人博客地址已搬家到CSDN，希望大家多多支持 最近利用hexo搭了一个博客主页，之前都是混掘金，但感觉掘金上的人越来越少了，是时候踏入下一个江湖啦~]]></content>
      <tags>
        <tag>搬家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli生成vue项目]]></title>
    <url>%2F2019%2F01%2F17%2Ffirst%2F</url>
    <content type="text"><![CDATA[全局安装 vue-cli1.$ cnpm install –global vue-cli 如果已经安装过了就不用安装了，这里我前面的项目已经安装过了，所以直接从第二步开始 my-project为自定义项目名2.$ vue init webpack my-project 需要注意的是项目的名称不能大写，不然会报错 项目初始化时会询问一些安装项，可以根据自己的需求选择 Project name (my-project) ==&gt;项目名称（我的项目） Project description (A Vue.js project) ==&gt;项目描述一个Vue.js 项目 Author 作者（你的名字） nstall vue-router? (Y/n) ==&gt;是否安装Vue路由，也就是以后是spa（但页面应用需要的模块）yes Use ESLint to lint your code? (Y/n) ==&gt;使用 ESLint 到你的代码？ （Y [ yes ] / N [ no ]）此处建议选no，如果不是按照ESLint风格，编译时就会报错（就是这里坑了我，找半天没发现逻辑问题） Pick an ESLint preset (Use arrow keys) ==&gt;选择一个预置ESLint（使用箭头键） Setup unit tests with Karma + Mocha? (Y/n) ==&gt;设置单元测Karma + Mocha？ （Y/ N） Setup e2e tests with Nightwatch? (Y/n) ==&gt;设置端到端测试，Nightwatch？这里需要选yes，否则会报websocket的错误 （Y/ N）Y 3.最后一步就是安心等待啦 完成后运行npm run Dev项目就运行起来啦 注： Vue取消eslint语法限制 在build/webpack.base.conf.js文件中，注释或者删除掉：module-&gt;rules中有关eslint的规则]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Git的基本使用]]></title>
    <url>%2F2019%2F01%2F17%2Fhello-world%2F</url>
    <content type="text"><![CDATA[“ 很早之前便注册了github，一直没有使用，正好这次搭建blogs可以熟悉下好久没用的git，当然，我对git的理解还是很粗浅的，主要还是通过Git教程 - 廖雪峰的官方网站来学习。” git的安装就不做介绍了，都是一直下一步的操作，我们直接进入git的操作。 第一步先创建一个本地的版本库（就是一个文件夹，随便在哪建一个） 第二步 通过git init 将这个文件夹变成git可管理的厂库 进入文件夹内右击打开git bash命令行窗口 第三步此时你会发现文件夹内多了一个.git的文件，这是用来跟踪和管理版本库的。它是默认隐藏的，如果你看不到，那就需要设置一下让隐藏文件可见 到了这一步，你就可以将自己的项目文件复制进来了然后通过git status 查看当前状态 第四步、看到文件状态后，再通过git add . 将改文件下的所有目录添加到厂库，然后用git commit -m &quot;注释&quot;把项目提交到仓库。-m后面的引号内是你本次提交的注释，这个可以随便写，或者空着 第五步将Git仓库与本地仓库进行关联（这个操作只用执行一次，关联后下次可直接进行提交） git remote add origin https://github.com/langhuonan/langhuonan.github.io.git git remote add origin 后面跟的是你github的仓库地址 第六步关联好后我们就可以吧本地库的内容推送到远程仓库github上啦 git push -u origin master (第一次推送由于远程库是空的，所以要加上-u这个参数，下次再传的时候只需要git push origin master) 至此就完成了将本地项目上传到远程库的整个过程]]></content>
      <categories>
        <category>web前端</category>
      </categories>
  </entry>
</search>
