---
title: es6基础之对象的扩展
tags: es6
categories: es6
date: 2019-03-13 10:19:34
---
本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下
[传送门](http://es6.ruanyifeng.com/#README)
### 对象的扩展运算符

#### 解构赋值
对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面
<!--more-->
```
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```
上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。

由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。
```
let { x, y, ...z } = null; // 运行时错误
let { x, y, ...z } = undefined; // 运行时错误
```

解构赋值必须是最后一个参数，否则会报错。
```
let { ...x, y, z } = someObject; // 句法错误
let { x, ...y, ...z } = someObject; // 句法错误
```
上面代码中，解构赋值不是最后一个参数，所以会报错

注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本
```
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
```
上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。


#### 扩展运算符

对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
```
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
```


由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。
```
let foo = { ...['a', 'b', 'c'] };
foo
// {0: "a", 1: "b", 2: "c"}
```
如果扩展运算符后面不是对象，则会自动将其转为对象
```
// 等同于 {...Object(1)}
{...1} // {}
```
上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。


但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象
```
{...'hello'}
// {0: "h", 1: "e", 2: "l", 3: "l", 4: "o"}
```
