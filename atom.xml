<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫气楠楠</title>
  <icon>https://www.gravatar.com/avatar/7124a429c575994ec398d35a1de49b3d</icon>
  <subtitle>记录点滴，分享世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-10T03:26:42.575Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lval</name>
    <email>m1921219654@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue的axios拦截器使用</title>
    <link href="http://yoursite.com/2019/05/10/19-05/19-5-10/"/>
    <id>http://yoursite.com/2019/05/10/19-05/19-5-10/</id>
    <published>2019-05-10T03:20:03.000Z</published>
    <updated>2019-05-10T03:26:42.575Z</updated>
    
    <content type="html"><![CDATA[<h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p>下载并使用axios后可以对全局进行拦截器设置。拦截器在发送请求前或响应返回时做一些特殊的处理。 </p><p>下面是一个为axios添加请求loading的例子：</p><h3 id="添加请求拦截器"><a href="#添加请求拦截器" class="headerlink" title="添加请求拦截器"></a>添加请求拦截器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义一个请求拦截器</span><br><span class="line">axios.interceptors.request.use(function(config)&#123;</span><br><span class="line">  Vue.$vux.loading.show(); //在请求发出之前进行一些操作</span><br><span class="line">  return config</span><br><span class="line">&#125;,function (error) &#123;</span><br><span class="line">  　　// 对请求错误做些什么</span><br><span class="line">  // return Promise.reject(error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="添加响应拦截器"><a href="#添加响应拦截器" class="headerlink" title="添加响应拦截器"></a>添加响应拦截器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义一个响应拦截器</span><br><span class="line">axios.interceptors.response.use(function(config)&#123;</span><br><span class="line">  Vue.$vux.loading.hide();;//在这里对返回的数据进行处理</span><br><span class="line">  return config</span><br><span class="line">&#125;,function (error) &#123;</span><br><span class="line">  　　// 对请求错误做些什么</span><br><span class="line">  // return Promise.reject(error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="移除拦截器"><a href="#移除拦截器" class="headerlink" title="移除拦截器"></a>移除拦截器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;axios拦截器&quot;&gt;&lt;a href=&quot;#axios拦截器&quot; class=&quot;headerlink&quot; title=&quot;axios拦截器&quot;&gt;&lt;/a&gt;axios拦截器&lt;/h3&gt;&lt;p&gt;下载并使用axios后可以对全局进行拦截器设置。拦截器在发送请求前或响应返回时做一些特殊的处
      
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue的计算属性和侦听器</title>
    <link href="http://yoursite.com/2019/05/07/19-05/19-5-7/"/>
    <id>http://yoursite.com/2019/05/07/19-05/19-5-7/</id>
    <published>2019-05-07T06:43:03.000Z</published>
    <updated>2019-05-07T07:20:30.923Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><h5 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h5><p>1、computed用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义，然后就可以在页面上获取到并进行相应的数据处理</p><p>2、computed里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。</p><a id="more"></a><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div @click=&apos;add&apos;&gt; + &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        num1: 11,</span><br><span class="line">        num2: 33</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">      total:function()&#123;</span><br><span class="line">      return this.num1 + this.num2 //总分会随着num1，num2的变化而重新计算</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      add()&#123;</span><br><span class="line">          this.num1++</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面案例中total返回的是num1和num2的总和，且每次点击加号时total的值都会随着num1的变化而变化，由此可知计算属性可以依赖多个Vue 实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。</p><h5 id="计算属性的setter"><a href="#计算属性的setter" class="headerlink" title="计算属性的setter"></a>计算属性的setter</h5><p>计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    // getter</span><br><span class="line">    get: function () &#123;</span><br><span class="line">      return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    // setter</span><br><span class="line">    set: function (newValue) &#123;</span><br><span class="line">      var names = newValue.split(&apos; &apos;)</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[names.length - 1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再运行 vm.fullName = ‘John Doe’ 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。</p><h3 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 watch"></a>侦听器 watch</h3><p>虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。<br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;watch-example&quot;&gt;</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    &lt;input v-model=&quot;question&quot;&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">watch: &#123;</span><br><span class="line">    // 如果 `question` 发生改变，这个函数就会运行</span><br><span class="line">    question: function (newQuestion, oldQuestion) &#123;</span><br><span class="line">      this.answer = &apos;Waiting for you to stop typing...&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>当我们监听的数据发生变化时，相应的函数就会运行，这个函数的第一个参数是变化的值，第二个参数是原来的值</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;计算属性&quot;&gt;&lt;a href=&quot;#计算属性&quot; class=&quot;headerlink&quot; title=&quot;计算属性&quot;&gt;&lt;/a&gt;计算属性&lt;/h3&gt;&lt;h5 id=&quot;理解&quot;&gt;&lt;a href=&quot;#理解&quot; class=&quot;headerlink&quot; title=&quot;理解&quot;&gt;&lt;/a&gt;理解&lt;/h5&gt;&lt;p&gt;1、computed用来监控自己定义的变量，该变量不在data里面声明，直接在computed里面定义，然后就可以在页面上获取到并进行相应的数据处理&lt;/p&gt;
&lt;p&gt;2、computed里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue图片上传</title>
    <link href="http://yoursite.com/2019/05/06/19-05/19-5-6/"/>
    <id>http://yoursite.com/2019/05/06/19-05/19-5-6/</id>
    <published>2019-05-06T05:43:03.000Z</published>
    <updated>2019-05-06T06:00:15.500Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将图片上传功能封装为一个组件（组件）"><a href="#将图片上传功能封装为一个组件（组件）" class="headerlink" title="将图片上传功能封装为一个组件（组件）"></a>将图片上传功能封装为一个组件（<imgupload>组件）</imgupload></h3><p>思路：使用input的file类型来上传图片，然后在利用FileReader读取到文件中的数据。</p><p>FileReader提供了如下方法：<br><img src="/2019/05/06/19-05/19-5-6/blog01.png" alt="zi">)<br><a id="more"></a><br>事件：<br><img src="/2019/05/06/19-05/19-5-6/blog02.png" alt="zi">)</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//结构</span><br><span class="line">&lt;template&gt;       </span><br><span class="line">&lt;div class=&quot;upload&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;file&quot;&gt;&lt;img :src=&quot;src&quot; alt=&quot;&quot;&gt;&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; @change=&quot;getFile&quot; ref=&quot;file&quot; id=&quot;file&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="图片上传的js"><a href="#图片上传的js" class="headerlink" title="图片上传的js"></a>图片上传的js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">//js</span><br><span class="line">import logo from &apos;../assets/images/index_logo.png&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">     return&#123;</span><br><span class="line">        src:logo</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        //base64转为formdata</span><br><span class="line">        dataURItoBlob(dataURI) &#123;</span><br><span class="line">            var byteString = atob(dataURI.split(&apos;,&apos;)[1]);</span><br><span class="line">            var mimeString = dataURI.split(&apos;,&apos;)[0].split(&apos;:&apos;)[1].split(&apos;;&apos;)[0];</span><br><span class="line">            var ab = new ArrayBuffer(byteString.length);</span><br><span class="line">            var ia = new Uint8Array(ab);</span><br><span class="line">            for (var i = 0; i &lt; byteString.length; i++) &#123;</span><br><span class="line">                ia[i] = byteString.charCodeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            return new Blob([ab], &#123;type: mimeString&#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        getFile:function(e)&#123;</span><br><span class="line">            let _this = this</span><br><span class="line">            let value_ = e.target</span><br><span class="line">            let files = e.target.files[0]//获取上传的图片</span><br><span class="line"></span><br><span class="line">            let size_ = 200;//文件限制的大小，单位为kb</span><br><span class="line">            let fileSize = (files.size / 1024).toFixed(0)//文件大小，单位kb</span><br><span class="line">            let fileType = value_.value.substring(value_.value.lastIndexOf(&quot;.&quot;))//文件格式</span><br><span class="line"></span><br><span class="line">            if (!e || !window.FileReader) &#123; return &#125;//是否支持FileReader</span><br><span class="line">            let reader = new FileReader()//new一个FileReader对象</span><br><span class="line">            reader.readAsDataURL(files) //将文件读取为 DataURL</span><br><span class="line">            //判断文件大小</span><br><span class="line">            if (fileSize &gt; size_) &#123;</span><br><span class="line">                alert(&apos;文件过大&apos;)</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (!fileType.match(/.jpg|.jpeg|.gif|.png|.bmp/i)) &#123;</span><br><span class="line">                alert(&apos;请上传正确格式的图片&apos;)</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            reader.onload = function()&#123;//文件读取成功result 属性返回读取的结果</span><br><span class="line">                _this.src = this.result//展示图片</span><br><span class="line">                //将base64转为formdata</span><br><span class="line">                var blob = _this.dataURItoBlob(this.result);</span><br><span class="line">                let format = new FormData()</span><br><span class="line">                format.append(&apos;src&apos;,blob)</span><br><span class="line">                _this.$emit(&apos;getImage&apos;,format)//将路径传出去</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组件的样式"><a href="#组件的样式" class="headerlink" title="组件的样式"></a>组件的样式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//样式</span><br><span class="line"> @r:2px;</span><br><span class="line">   .upload img&#123;</span><br><span class="line">        display: block;</span><br><span class="line">        width: 108/@r;</span><br><span class="line">        height: 108/@r;</span><br><span class="line">        margin-bottom: 34/@r;</span><br><span class="line">    &#125;</span><br><span class="line">   .upload input &#123;</span><br><span class="line">        display: none;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>上面将上传功能封装为imgupload组件，下面开始在其他需要的组件内调用</p><p>1、引入组件<br><code>import imgupload from &#39;../common/imgupload&#39;</code><br>2、命名组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">   components:&#123;imgupload&#125;,//组件名称</span><br><span class="line">   created()&#123;</span><br><span class="line"></span><br><span class="line">   &#125;,</span><br><span class="line">   data()&#123;</span><br><span class="line">       return &#123;</span><br><span class="line">           addMask:true,</span><br><span class="line">           src:logo</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure></p><p>3、调用组件<br>组件间的关系是使用时产生的，在这里使用imgupload组件，所以imgupload组件是子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;imgupload @getImage=&apos;getImage&apos;&gt;&lt;/imgupload&gt;</span><br></pre></td></tr></table></figure></p><p>上传的图片需要传给后台，所以imgupload组件需要将图片传出来，这里imgupload组件是子组件，子传父使用事件传值（上面代码中的_this.$emit(‘getImage’,format)将图片传出来）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">            </span><br><span class="line">    getImage(imgsrc)&#123;</span><br><span class="line">        //imgsrc是imgupload组件传出来的图片数据</span><br><span class="line">        this.src=imgsrc</span><br><span class="line">        // console.log(src)</span><br><span class="line">        </span><br><span class="line">        console.log(imgsrc.get(&apos;src&apos;),&apos;666&apos;)</span><br><span class="line">        //ajax</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;将图片上传功能封装为一个组件（组件）&quot;&gt;&lt;a href=&quot;#将图片上传功能封装为一个组件（组件）&quot; class=&quot;headerlink&quot; title=&quot;将图片上传功能封装为一个组件（组件）&quot;&gt;&lt;/a&gt;将图片上传功能封装为一个组件（&lt;imgupload&gt;组件）&lt;/imgupload&gt;&lt;/h3&gt;&lt;p&gt;思路：使用input的file类型来上传图片，然后在利用FileReader读取到文件中的数据。&lt;/p&gt;
&lt;p&gt;FileReader提供了如下方法：&lt;br&gt;&lt;img src=&quot;/2019/05/06/19-05/19-5-6/blog01.png&quot; alt=&quot;zi&quot;&gt;)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>input输入框获取焦点后，底部固定定位的按钮顶起问题</title>
    <link href="http://yoursite.com/2019/04/30/19-04/19-4-30/"/>
    <id>http://yoursite.com/2019/04/30/19-04/19-4-30/</id>
    <published>2019-04-30T01:43:03.000Z</published>
    <updated>2019-04-30T02:02:45.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>问题：手机H5页面当input输入框获取焦点时，软键盘会弹起，这时：IOS底部固定定位的按钮不会随着键盘弹起而弹起；而安卓底部固定定位的按钮会跟随软键盘弹起而顶起，从而遮挡一部分视图</p><h3 id="解决方法一、监听window的resize事件，控制显示隐藏"><a href="#解决方法一、监听window的resize事件，控制显示隐藏" class="headerlink" title="解决方法一、监听window的resize事件，控制显示隐藏"></a>解决方法一、监听window的resize事件，控制显示隐藏</h3><p>此方法只对安卓有用，iOS没有监听window的resize事件（iOS的话还是用flex布局比较好）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 获取视图原始高度</span><br><span class="line">let screenHeight = document.body.offsetHeight</span><br><span class="line">// 为window绑定resize事件</span><br><span class="line">window.onresize = function () &#123;</span><br><span class="line">      let changeHeight = document.body.offsetHeight</span><br><span class="line">      if (changeHeight &lt; screenHeight) &#123;</span><br><span class="line">        // 隐藏被弹起的固定定位</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 显示</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="解决方法二、flex布局"><a href="#解决方法二、flex布局" class="headerlink" title="解决方法二、flex布局"></a>解决方法二、flex布局</h3><p>将屏幕分为上下两部分，主体为一部分，底部一部分，主体部分设置为flex:1,overflow: scroll;内容在主体内滑动，底部固定不动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//样式</span><br><span class="line">html,body &#123;</span><br><span class="line">        height: 100%;</span><br><span class="line">        width: 100%;</span><br><span class="line">    &#125;</span><br><span class="line">.container &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//需要滑动的主体内容设置为flex:1;overflow: scroll,这样当内容超出时只会在主体内滑动，而不会被底部固定的部分影响</span><br><span class="line">.main &#123;</span><br><span class="line">        flex:1;</span><br><span class="line">        width: 100%;</span><br><span class="line">        background-color:pink;</span><br><span class="line">        overflow: scroll;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//需要固定不动的部分设置固定的高，</span><br><span class="line">.foot &#123;</span><br><span class="line">    height: 200px;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background-color: #000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结构</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;main&quot;&gt;</span><br><span class="line">        &lt;p&gt;dsadasdsadsadsadasdsadasdsadasdsaddsadasdsadsadsadasdsadasdsadasdsad&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;foot&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;问题：手机H5页面当input输入框获取焦点时，软键盘会弹起，这时：IOS底部固定定位的按钮不会随着键盘弹起而弹起；而安卓底部固定定位的按钮会跟随软键盘弹起而顶起，从而遮挡一部分视图&lt;/p&gt;
&lt;h3 id=&quot;解决方法一、监听window的resize事件，控制显示隐藏&quot;&gt;&lt;a href=&quot;#解决方法一、监听window的resize事件，控制显示隐藏&quot; class=&quot;headerlink&quot; title=&quot;解决方法一、监听window的resize事件，控制显示隐藏&quot;&gt;&lt;/a&gt;解决方法一、监听window的resize事件，控制显示隐藏&lt;/h3&gt;&lt;p&gt;此方法只对安卓有用，iOS没有监听window的resize事件（iOS的话还是用flex布局比较好）&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 获取视图原始高度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let screenHeight = document.body.offsetHeight	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 为window绑定resize事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;window.onresize = function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      let changeHeight = document.body.offsetHeight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if (changeHeight &amp;lt; screenHeight) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 隐藏被弹起的固定定位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>hexo主题上传报错Template render error</title>
    <link href="http://yoursite.com/2019/04/29/19-04/19-4-29/"/>
    <id>http://yoursite.com/2019/04/29/19-04/19-4-29/</id>
    <published>2019-04-29T05:45:03.000Z</published>
    <updated>2019-04-28T05:58:47.029Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板渲染错误"><a href="#模板渲染错误" class="headerlink" title="模板渲染错误"></a>模板渲染错误</h3><p>出现原因：文章内有一些不能用的字符，导致.md格式文章转换报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..\source\_posts目录下的文章</span><br></pre></td></tr></table></figure><p>解决方法：解决方案：仔细检查..\source_posts目录下的文章，有没有“{ }”等符号，或者代码没有被放入代码框内</p><p>注意：这里的代码框用多行代码框，单行代码框无效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模板渲染错误&quot;&gt;&lt;a href=&quot;#模板渲染错误&quot; class=&quot;headerlink&quot; title=&quot;模板渲染错误&quot;&gt;&lt;/a&gt;模板渲染错误&lt;/h3&gt;&lt;p&gt;出现原因：文章内有一些不能用的字符，导致.md格式文章转换报错&lt;/p&gt;
&lt;figure class=&quot;hig
      
    
    </summary>
    
      <category term="主题相关" scheme="http://yoursite.com/categories/%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="主题相关" scheme="http://yoursite.com/tags/%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目执行npm i安装依赖中出现的问题</title>
    <link href="http://yoursite.com/2019/04/28/19-04/19-4-28/"/>
    <id>http://yoursite.com/2019/04/28/19-04/19-4-28/</id>
    <published>2019-04-28T05:45:03.000Z</published>
    <updated>2019-04-28T06:03:49.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="报错chromedriver"><a href="#报错chromedriver" class="headerlink" title="报错chromedriver"></a>报错chromedriver</h3><p><img src="/2019/04/28/19-04/19-4-28/01.png" alt="zi"></p><p>出现原因：没有安装chromedriver</p><p>解决方法：执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install chromedriver --chromedriver_cdnurl=http://cdn.npm.taobao.org/dist/chromedriver</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;报错chromedriver&quot;&gt;&lt;a href=&quot;#报错chromedriver&quot; class=&quot;headerlink&quot; title=&quot;报错chromedriver&quot;&gt;&lt;/a&gt;报错chromedriver&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/2019/04/28/
      
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue过滤器 filter</title>
    <link href="http://yoursite.com/2019/04/25/19-04/19-4-25/"/>
    <id>http://yoursite.com/2019/04/25/19-04/19-4-25/</id>
    <published>2019-04-25T02:57:03.000Z</published>
    <updated>2019-04-28T05:31:09.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化(比如在123后面加上abc,或者将一些状态值转为具体的描述：state=0显示‘已领取’等)。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在双花括号中 --&gt;</span><br><span class="line">&#123;&#123; message | capitalize &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 在 `v-bind` 中 --&gt;</span><br><span class="line">&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>在创建 Vue 实例之前全局定义过滤器:</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(&apos;capitalize&apos;, function (value) &#123;</span><br><span class="line">if (!value) return &apos;&apos;</span><br><span class="line">value = value.toString()</span><br><span class="line">return value.charAt(0).toUpperCase() + value.slice(1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">// ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre><h3 id="组件过滤器（局部）"><a href="#组件过滤器（局部）" class="headerlink" title="组件过滤器（局部）"></a>组件过滤器（局部）</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;status&quot;&gt;&#123;&#123;item.is_verify|prizeState&#125;&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//filters过滤器是和生命周期是同级的</span><br><span class="line">created()&#123;</span><br><span class="line">        this.getPrizeList()</span><br><span class="line">    &#125;,</span><br><span class="line">filters:&#123;</span><br><span class="line">        prizeState:function(val)&#123;//参数val就是上面的item.is_verify,花括号内的插值会是prizeState中return出来的数据</span><br><span class="line">            if(val==0)&#123;</span><br><span class="line">                return &apos;未使用&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            if(val==1)&#123;</span><br><span class="line">                return &apos;已使用&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            if(val==11)&#123;</span><br><span class="line">                return &apos;未开始&apos;</span><br><span class="line">            &#125;</span><br><span class="line">            if(val==12)&#123;</span><br><span class="line">                return &apos;已过期&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></code></pre><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>1、过滤器函数总接收表达式的值 (之前的操作链的结果) 作为第一个参数。在上述例子中，prizeState 过滤器函数将会收到 item.is_verify 的值作为第一个参数，插值的内容会变为prizeState函数return出去的数据</p><p>如上述例子，如果item.is_verify的值是1，插值就会是‘未使用’</p><p>2、过滤器可以串联<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>上面的这个例子中filterA接收的参数是message，filterB接收的是filterA中return出来的结果</p><p>3、过滤器是 JavaScript 函数，因此可以接收参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(参1, 参2) &#125;&#125;</span><br></pre></td></tr></table></figure></p><p>如上：filterA 被定义为接收三个参数的过滤器函数，第一个参数是message，剩下两个参数是传到filterA中的两参数</p><h3 id="注意：全局注册时是filter，没有s的。而组件过滤器是filters，是有s的。"><a href="#注意：全局注册时是filter，没有s的。而组件过滤器是filters，是有s的。" class="headerlink" title="注意：全局注册时是filter，没有s的。而组件过滤器是filters，是有s的。"></a>注意：全局注册时是filter，没有s的。而组件过滤器是filters，是有s的。</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h3&gt;&lt;p&gt;Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化(比如在123后面加上abc,或者将一些状态值转为具体的描述：state=0显示‘已领取’等)。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式&lt;br&gt;    &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 在双花括号中 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&amp;#123; message | capitalize &amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 在 `v-bind` 中 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div v-bind:id=&amp;quot;rawId | formatId&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue使用axios</title>
    <link href="http://yoursite.com/2019/04/18/19-04/19-4-18-2/"/>
    <id>http://yoursite.com/2019/04/18/19-04/19-4-18-2/</id>
    <published>2019-04-18T07:23:03.000Z</published>
    <updated>2019-04-18T07:42:10.332Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p><code>npm install axios --save-dev</code></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p><code>import axios from &#39;axios&#39;</code></p><h3 id="将axios绑定给vue成为一个属性-这样可以在任意组件中使用"><a href="#将axios绑定给vue成为一个属性-这样可以在任意组件中使用" class="headerlink" title="将axios绑定给vue成为一个属性,这样可以在任意组件中使用"></a>将axios绑定给vue成为一个属性,这样可以在任意组件中使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置axios请求的默认host</span><br><span class="line">//axios.defaults.baseURL = &apos;https://wechat.kayunzh.com&apos;</span><br><span class="line"></span><br><span class="line">//将axios注入到vue原型上</span><br><span class="line">Vue.prototype.$http = axios</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>get方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.$http(&#123;</span><br><span class="line">    method:&apos;get&apos;,</span><br><span class="line">    url:&apos;https://wechat.kayunzh.com/gongzhonghao/Jssdk&apos;,</span><br><span class="line">    params:&#123;</span><br><span class="line">        // 代码需要上传服务器，否则返回为0</span><br><span class="line">        url:location.href.split(&apos;#&apos;)[0],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    this.init(res.data.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>post方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.$http(&#123;</span><br><span class="line">    method:&apos;post&apos;,</span><br><span class="line">    url:&apos;https://ssl2.xupengfei.net/wx/web_page/getUserInfoByCode&apos;,</span><br><span class="line">    data:&#123;</span><br><span class="line">        code:geturlcode</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;).then(res=&gt;&#123;</span><br><span class="line">    if(res.data.code==0)&#123;</span><br><span class="line">        this.$store.commit(&apos;hasopenId&apos;,res.data.data)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>axios 是基于promise的http库，支持promise API，比如常用的异步回调问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">this.$http(&#123;</span><br><span class="line">    method:&apos;get&apos;,</span><br><span class="line">    url:&apos;https://wechat.kayunzh.com/gongzhonghao/Jssdk&apos;,</span><br><span class="line">    params:&#123;</span><br><span class="line">        // 代码需要上传服务器，否则返回为0</span><br><span class="line">        url:location.href.split(&apos;#&apos;)[0],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    this.init(res.data.data)</span><br><span class="line">    //请求成功后发送下一个请求</span><br><span class="line">    return this.$http(&#123;</span><br><span class="line">        //发送请求</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">    //res是上面请求返回的数据</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h3&gt;&lt;p&gt;&lt;code&gt;npm install axios --save-dev&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;&lt;code&gt;import axios from &amp;#39;axios&amp;#39;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;将axios绑定给vue成为一个属性-这样可以在任意组件中使用&quot;&gt;&lt;a href=&quot;#将axios绑定给vue成为一个属性-这样可以在任意组件中使用&quot; class=&quot;headerlink&quot; title=&quot;将axios绑定给vue成为一个属性,这样可以在任意组件中使用&quot;&gt;&lt;/a&gt;将axios绑定给vue成为一个属性,这样可以在任意组件中使用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//设置axios请求的默认host&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//axios.defaults.baseURL = &amp;apos;https://wechat.kayunzh.com&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//将axios注入到vue原型上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.prototype.$http = axios&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>截取地址栏url参数</title>
    <link href="http://yoursite.com/2019/04/18/19-04/19-4-18-3/"/>
    <id>http://yoursite.com/2019/04/18/19-04/19-4-18-3/</id>
    <published>2019-04-18T06:43:03.000Z</published>
    <updated>2019-04-18T07:47:33.236Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下面是一个截取url参数的方法"><a href="#下面是一个截取url参数的方法" class="headerlink" title="下面是一个截取url参数的方法"></a>下面是一个截取url参数的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//参数name就是我们要截取的字段参数,比如我们要截取地址栏问号后面的id，可以直接这样调用getsearch(&apos;id&apos;)</span><br><span class="line">getsearch:function(name)&#123;</span><br><span class="line">    var reg = new RegExp(&quot;(^|&amp;)&quot;+ name +&quot;=([^&amp;]*)(&amp;|$)&quot;);</span><br><span class="line">    var r = window.location.search.substr(1).match(reg);</span><br><span class="line">    if(r!=null)return unescape(r[2]); return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;下面是一个截取url参数的方法&quot;&gt;&lt;a href=&quot;#下面是一个截取url参数的方法&quot; class=&quot;headerlink&quot; title=&quot;下面是一个截取url参数的方法&quot;&gt;&lt;/a&gt;下面是一个截取url参数的方法&lt;/h3&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>移动端的视口设置</title>
    <link href="http://yoursite.com/2019/04/18/19-04/19-4-18/"/>
    <id>http://yoursite.com/2019/04/18/19-04/19-4-18/</id>
    <published>2019-04-18T06:23:03.000Z</published>
    <updated>2019-04-17T07:15:34.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="视口的设置"><a href="#视口的设置" class="headerlink" title="视口的设置"></a>视口的设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><p>以上代码常见于移动端设置，他的作用是使网页的宽度自动适应手机屏幕的宽度。</p><p>下面对每个属性的详细说明：</p><table><thead><tr><th style="text-align:left">属性名</th><th style="text-align:center">取值</th><th style="text-align:right">描述</th></tr></thead><tbody><tr><td style="text-align:left">width</td><td style="text-align:center">device-width或正整数</td><td style="text-align:right">定义视口的宽度，单位为像素，一般为device-width：表示宽度为设备屏幕的宽度</td></tr><tr><td style="text-align:left">height</td><td style="text-align:center">device-width或正整数</td><td style="text-align:right">定义视口的高度，单位为像素，一般不用写</td></tr><tr><td style="text-align:left">initial-scale</td><td style="text-align:center">[0.0-10.0]</td><td style="text-align:right">定义初始缩放值，一般设置为1.0</td></tr><tr><td style="text-align:left">minimum-scale</td><td style="text-align:center">[0.0-10.0]</td><td style="text-align:right">定义放大最大比例，它必须小于或等于maximum-scale设置</td></tr><tr><td style="text-align:left">maximum-scale</td><td style="text-align:center">[0.0-10.0]</td><td style="text-align:right">定义缩小最小比例，它必须大于或等于minimum-scale设置</td></tr><tr><td style="text-align:left">user-scalable</td><td style="text-align:center">yes / no</td><td style="text-align:right">定义是否允许用户手动缩放页面，默认值 yes</td></tr></tbody></table><p>注意：</p><p>viewport 标签只对移动端浏览器有效，对 PC 端浏览器是无效的</p><p>当缩放比例为 100% 时，dip 宽度 = CSS 像素宽度 = 理想视口的宽度 = 布局视口的宽度</p><p>单独设置 initial-scale 或 width 都会有兼容性问题，所以设置布局视口为理想视口的最佳方法是同时设置这两个属性</p><p>即使设置了 user-scalable = no，在 Android Chrome 浏览器中也可以强制启用手动缩放</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;视口的设置&quot;&gt;&lt;a href=&quot;#视口的设置&quot; class=&quot;headerlink&quot; title=&quot;视口的设置&quot;&gt;&lt;/a&gt;视口的设置&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>css的视口单位vw、vh的使用</title>
    <link href="http://yoursite.com/2019/04/17/19-04/19-4-17/"/>
    <id>http://yoursite.com/2019/04/17/19-04/19-4-17/</id>
    <published>2019-04-17T06:20:03.000Z</published>
    <updated>2019-04-17T07:49:01.992Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是视口？"><a href="#什么是视口？" class="headerlink" title="什么是视口？"></a>什么是视口？</h3><p>在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。</p><p>视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport。</p><h3 id="视口单位"><a href="#视口单位" class="headerlink" title="视口单位"></a>视口单位</h3><p>根据CSS3规范，视口单位主要包括以下4个：</p><pre><code>1.vw：1vw等于视口宽度的1%。2.vh：1vh等于视口高度的1%。3.vmin：选取vw和vh中最小的那个。4.vmax：选取vw和vh中最大的那个</code></pre><a id="more"></a><h3 id="vh，vw与百分比的区别"><a href="#vh，vw与百分比的区别" class="headerlink" title="vh，vw与百分比的区别"></a>vh，vw与百分比的区别</h3><pre><code>1.% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。2.vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，是无法正确获得可视区域的高度的3.vmax相对于视口的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax。4.vmin相对于视口的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin。</code></pre><h3 id="视口单位vw-wh的用处"><a href="#视口单位vw-wh的用处" class="headerlink" title="视口单位vw,wh的用处"></a>视口单位vw,wh的用处</h3><pre><code>1.响应式页面由于vw，vh的特性，他们能够根据窗口大小来自动调节字体大小，这就能很轻松地完成响应式页面的布局2.可以使用vw，vh来实现在页面中响应垂直居中<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.main &#123; </span><br><span class="line">width: 50vw; </span><br><span class="line">height: 50vh; </span><br><span class="line">margin: 25vh auto; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>只要设置margin的上下间距，使之heigit + margin-top +margin-bottom = 100 ，width + margin-left + margin-right = 100 ，就能够响应垂直居中3.模仿bootstrap的栅栏布局bootstrap的特点就是它的栅栏布局，而使用vw，vh就能够轻松实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.row1&#123; </span><br><span class="line">    float: left; </span><br><span class="line">    width:50vw;</span><br><span class="line">&#125;</span><br><span class="line">.row1&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width:25vw;</span><br><span class="line">&#125;</span><br><span class="line">.row1&#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width:25vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>只要在一行中所有的列加起来等于100vw就实现响应式布局</code></pre><h3 id="仅使用vw作为CSS单位"><a href="#仅使用vw作为CSS单位" class="headerlink" title="仅使用vw作为CSS单位"></a>仅使用vw作为CSS单位</h3><pre><code>在仅使用 vw 单位作为唯一应用的一种 CSS 单位的这种做法下，我们遵守：1.对于设计稿的尺寸转换为vw单位，我们使用Sass函数编译<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//iPhone 6尺寸作为设计稿基准</span><br><span class="line">$vm_base: 375; </span><br><span class="line">@function vw($px) &#123;</span><br><span class="line">    @return ($px / 375) * 100vw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>2.无论是文本还是布局高宽、间距等都使用 vw 作为 CSS 单位<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.logo&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    width: vm(40); // 宽度</span><br><span class="line">    height: vm(40); // 高度</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="vmin、vmax-用处"><a href="#vmin、vmax-用处" class="headerlink" title="vmin、vmax 用处"></a>vmin、vmax 用处</h3><pre><code>做移动页面开发时，如果使用 vw、wh 设置字体大小（比如 5vw），在竖屏和横屏状态下显示的字体大小是不一样的。由于 vmin 和 vmax 是当前较小的 vw 和 vh 和当前较大的 vw 和 vh。这里就可以用到 vmin 和 vmax。使得文字大小在横竖屏下保持一致。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是视口？&quot;&gt;&lt;a href=&quot;#什么是视口？&quot; class=&quot;headerlink&quot; title=&quot;什么是视口？&quot;&gt;&lt;/a&gt;什么是视口？&lt;/h3&gt;&lt;p&gt;在桌面端，视口指的是在桌面端，指的是浏览器的可视区域；而在移动端，它涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口）。&lt;/p&gt;
&lt;p&gt;视口单位中的“视口”，桌面端指的是浏览器的可视区域；移动端指的就是Viewport中的Layout Viewport。&lt;/p&gt;
&lt;h3 id=&quot;视口单位&quot;&gt;&lt;a href=&quot;#视口单位&quot; class=&quot;headerlink&quot; title=&quot;视口单位&quot;&gt;&lt;/a&gt;视口单位&lt;/h3&gt;&lt;p&gt;根据CSS3规范，视口单位主要包括以下4个：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.vw：1vw等于视口宽度的1%。

2.vh：1vh等于视口高度的1%。

3.vmin：选取vw和vh中最小的那个。

4.vmax：选取vw和vh中最大的那个
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>小程序swiper组件用箭头控制无法衔接</title>
    <link href="http://yoursite.com/2019/04/10/19-04/19-4-10/"/>
    <id>http://yoursite.com/2019/04/10/19-04/19-4-10/</id>
    <published>2019-04-10T06:23:03.000Z</published>
    <updated>2019-04-10T09:33:33.280Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>小程序组件swiper左右滑动，自动轮播时circular衔接效果都是没有问题的，但当我们用左右箭头模拟轮播的时候，衔接效果却失效了，问题出在哪里？<br>我们来看下面一段代码：<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//wxml</span><br><span class="line"> &lt;view class=&apos;swiperbox&apos;&gt;</span><br><span class="line">    &lt;swiper class=&apos;swiper-content&apos; circular=&quot;true&quot; style=&quot;height:&#123;&#123;Height&#125;&#125;;&quot; current=&apos;&#123;&#123;current&#125;&#125;&apos; circular=&apos;true&apos;</span><br><span class="line">    bindchange=&quot;demo&quot; autoplay=&apos;&#123;&#123;autoplay&#125;&#125;&apos; interval=&quot;&#123;&#123;interval&#125;&#125;&quot;&gt;</span><br><span class="line">    &lt;swiper-item wx:for=&quot;&#123;&#123;swiperData&#125;&#125;&quot; wx:key=&quot;index&quot;&gt;</span><br><span class="line">        &lt;image src=&apos;&#123;&#123;item&#125;&#125;&apos;&gt;&lt;/image&gt;</span><br><span class="line">        &lt;view class=&apos;page&apos;&gt;&#123;&#123;index+1&#125;&#125;/&#123;&#123;swiperData.length&#125;&#125;&lt;/view&gt;</span><br><span class="line">    &lt;/swiper-item&gt;</span><br><span class="line">    &lt;/swiper&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line">&lt;view class=&apos;bottom&apos;&gt;</span><br><span class="line">    &lt;view class=&apos;btn-left&apos; bindtap=&apos;prev&apos;&gt;&lt;image src=&apos;&#123;&#123;AppImg.pptpageleft&#125;&#125;&apos;&gt;&lt;/image&gt;&lt;/view&gt;</span><br><span class="line">    &lt;view class=&apos;btn-right&apos; bindtap=&apos;next&apos;&gt;&lt;image src=&apos;&#123;&#123;AppImg.pptpageright&#125;&#125;&apos;&gt;&lt;/image&gt;&lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">//js</span><br><span class="line"> data: &#123;</span><br><span class="line">    AppImg: util.AppImg,</span><br><span class="line">    Height: &apos;530rpx&apos;,</span><br><span class="line">    swiperData:[</span><br><span class="line">      &apos;../img/demo.png&apos;,</span><br><span class="line">      &apos;../img/demo.png&apos;,</span><br><span class="line">      &apos;../img/demo.png&apos;</span><br><span class="line">    ],</span><br><span class="line">    current:0,</span><br><span class="line">    interval: 100,</span><br><span class="line">    autoplay: false,</span><br><span class="line">  &#125;,</span><br><span class="line">//下一页</span><br><span class="line"> next:function()&#123;</span><br><span class="line">    let count = this.data.current</span><br><span class="line">    count = count &lt; (this.data.swiperData.length - 1) ? count + 1 : 0;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      current:count</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">//current改变时触发的change事件</span><br><span class="line">  demo:function(e)&#123;</span><br><span class="line">    console.log(e.detail.source)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>上面代码中，滑动时source（来源）打印的是touch，自动轮播时打印的是autoplay，但我们点击下一页时，打印的却是空，那么，我们猜测是swiper组件只内置了滑动与自动轮播的机制，没有点击下一页的机制，<br>当我们用箭头模拟时，swiper无法在内部找到source来源，所以无法衔接滑动了，既然知道了是source的原因，那么我们要考虑的就是如何模拟swiper内部机制了，<br>那如何去模拟呢，这就要从autoplay这个内置属性搞事情了。</p><p>思路：将autoplay默认为false，点击下一页，将autoplay重置为true，检测bindchange事件的source来源，如果是autoplay，就做动态关闭处理将其设置为false，每一变化都将当前的current记录下来（不记录的话点击上一页跳转位置会错乱）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">   AppImg: util.AppImg,</span><br><span class="line">   Height: &apos;530rpx&apos;,</span><br><span class="line">   swiperData:[</span><br><span class="line">     &apos;../img/demo.png&apos;,</span><br><span class="line">     &apos;../img/demo.png&apos;,</span><br><span class="line">     &apos;../img/demo.png&apos;</span><br><span class="line">   ],</span><br><span class="line">   current:0,</span><br><span class="line">   interval: 100,</span><br><span class="line">   autoplay: false,</span><br><span class="line"> &#125;,</span><br><span class="line"> //上一页</span><br><span class="line"> prev:function()&#123;</span><br><span class="line">   let count = this.data.current</span><br><span class="line">   count = count&gt;0?count-1:this.data.swiperData.length-1</span><br><span class="line">   this.setData(&#123;</span><br><span class="line">     current:count</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> //下一页</span><br><span class="line"> next:function()&#123;</span><br><span class="line">   this.setData(&#123;</span><br><span class="line">     autoplay:true</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br><span class="line"> //当前页current改变时触发的change事件</span><br><span class="line"> demo:function(e)&#123;</span><br><span class="line">   console.log(e.detail.source)</span><br><span class="line">   if(e.detail.source==&apos;autoplay&apos;)&#123;</span><br><span class="line">     this.setData(&#123;</span><br><span class="line">       autoplay:false</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">     current: e.detail.current//记录下当前的滑块位置</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h4&gt;&lt;p&gt;小程序组件swiper左右滑动，自动轮播时circular衔接效果都是没有问题的，但当我们用左右箭头模拟轮播的时候，衔接效果却失效了，问题出在哪里？&lt;br&gt;我们来看下面一段代码：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>vue九宫格抽奖功能</title>
    <link href="http://yoursite.com/2019/04/04/19-04/19-4-4/"/>
    <id>http://yoursite.com/2019/04/04/19-04/19-4-4/</id>
    <published>2019-04-04T07:47:03.000Z</published>
    <updated>2019-04-04T07:59:15.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue九宫格抽奖"><a href="#vue九宫格抽奖" class="headerlink" title="vue九宫格抽奖"></a>vue九宫格抽奖</h3><p>页面结构<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;gift-box&quot;&gt;</span><br><span class="line"> &lt;ul&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==0?&apos;active&apos;:&apos;&apos;]&quot;&gt;一等奖&lt;/li&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==1?&apos;active&apos;:&apos;&apos;]&quot;&gt;二等奖&lt;/li&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==2?&apos;active&apos;:&apos;&apos;]&quot;&gt;三等奖&lt;/li&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==3?&apos;active&apos;:&apos;&apos;]&quot;&gt;四等奖&lt;/li&gt;</span><br><span class="line"> &lt;a :class=&quot;&#123;cur:curshow&#125;&quot; @click=&quot;startRoll&quot;&gt;开始&lt;/a&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==4?&apos;active&apos;:&apos;&apos;]&quot;&gt;五等奖&lt;/li&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==5?&apos;active&apos;:&apos;&apos;]&quot;&gt;六等奖&lt;/li&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==6?&apos;active&apos;:&apos;&apos;]&quot;&gt;七等奖&lt;/li&gt;</span><br><span class="line"> &lt;li :class=&quot;[index==7?&apos;active&apos;:&apos;&apos;]&quot;&gt;八等奖&lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin:0;padding:0;&#125;</span><br><span class="line">#gift-box&#123;width:310px;height:310px;margin:30px auto;&#125;</span><br><span class="line">ul&#123;width:310px;height:310px;list-style:none;&#125;</span><br><span class="line">ul li,ul a&#123;width:100px;height:100px;border:1px solid #565656;float:left;text-align:center;line-height:100px;&#125;</span><br><span class="line">ul a:hover&#123;cursor:pointer;color:orange;font-size:18px;&#125;</span><br><span class="line">ul .active&#123;background:red;color:#fff;&#125;</span><br><span class="line">.cur &#123;background-color: #ccc;&#125;</span><br></pre></td></tr></table></figure></p><p> 思路：点击开始抽奖，调用转动的方法，如果达到转动次数要求，且转到中奖位置，则停止，否则继续抽奖<br> js<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">       index: -1,// 当前转动到哪个位置，起点位置</span><br><span class="line">       count: 8,//总共有多少位置</span><br><span class="line">       timer: 0,//每次转动定时器</span><br><span class="line">       speed: 200,//初始转动速度</span><br><span class="line">       times: 0,// 转动次数</span><br><span class="line">       cycle: 3,//转动基数：至少需要转动多少次再进入抽奖环节</span><br><span class="line">       prize: 5,//中奖位置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">     // 开始抽奖</span><br><span class="line">       startRoll:function()&#123;</span><br><span class="line">           this.times+=1//转动次数</span><br><span class="line">           this.oneRoll()// 转动过程调用的每一次转动方法，这里是第一次调用初始化</span><br><span class="line">           this.usePrize()</span><br><span class="line">       &#125;,</span><br><span class="line">       // 转动的方法</span><br><span class="line">       oneRoll:function()&#123;</span><br><span class="line">           let index = this.index //当前转动到的位置</span><br><span class="line">           const count = 8 //总共的位置</span><br><span class="line">           index += 1</span><br><span class="line">           if(index &gt;count - 1)&#123;</span><br><span class="line">               index = 0</span><br><span class="line">           &#125;</span><br><span class="line">           this.index = index</span><br><span class="line">       &#125;,</span><br><span class="line">       //判断是否转到中奖位置，如果是，停止，如果不是，继续转动</span><br><span class="line">       usePrize:function()&#123;</span><br><span class="line">           // 判断是否达到转动次数要求且转到的位置是中奖位置</span><br><span class="line">           if(this.times &gt; this.cycle + 10 &amp;&amp; this.prize === this.index) &#123;</span><br><span class="line">               clearTimeout(this.timer) //清除定时器，转动停止</span><br><span class="line">               this.times = 0</span><br><span class="line">               this.giftopen = true //显示开奖界面</span><br><span class="line">               // alert(&apos;恭喜你，中奖了&apos;)</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               //否则继续转动</span><br><span class="line">               if(this.times&lt;this.cycle)&#123;</span><br><span class="line">                   this.speed-=5</span><br><span class="line">               &#125;</span><br><span class="line">               this.timer = setTimeout(this.startRoll, this.speed)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;vue九宫格抽奖&quot;&gt;&lt;a href=&quot;#vue九宫格抽奖&quot; class=&quot;headerlink&quot; title=&quot;vue九宫格抽奖&quot;&gt;&lt;/a&gt;vue九宫格抽奖&lt;/h3&gt;&lt;p&gt;页面结构&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue中引入iconfont</title>
    <link href="http://yoursite.com/2019/04/03/19-04/19-4-3/"/>
    <id>http://yoursite.com/2019/04/03/19-04/19-4-3/</id>
    <published>2019-04-03T06:23:03.000Z</published>
    <updated>2019-04-03T06:32:21.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="vue中引入iconfont"><a href="#vue中引入iconfont" class="headerlink" title="vue中引入iconfont"></a>vue中引入iconfont</h3><ol><li><p>打开 iconFont官网 选择自己喜欢的图标，并且添加购物车</p></li><li><p>将选好的图标下载到本地,并复制到assets目录下</p></li><li><p>在main.js中引入文件中的iconfont.css文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./assets/iconfont/iconfont.css&apos;</span><br></pre></td></tr></table></figure></li><li><p>然后就可以用啦</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;pp&quot;&gt;&lt;i class=&quot;iconfont icon-tongzhigonggao&quot;&gt;&lt;/i&gt;666&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><p>注意：如果没有下载css-loader依赖包，可能会报如下错误，需要下载一下npm install css-loader –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">These relative modules were not found:</span><br><span class="line"></span><br><span class="line">* ./iconfont.eot?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css</span><br><span class="line">* ./iconfont.svg?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css</span><br><span class="line">* ./iconfont.ttf?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css</span><br><span class="line">* ./iconfont.woff?t=1554271744964 in ./node_modules/css-loader??ref--6-1!./node_modules/postcss-loader/lib??ref--6-2!./src/assets/iconfont/iconfont.css</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;vue中引入iconfont&quot;&gt;&lt;a href=&quot;#vue中引入iconfont&quot; class=&quot;headerlink&quot; title=&quot;vue中引入iconfont&quot;&gt;&lt;/a&gt;vue中引入iconfont&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;打开 iconFont官网
      
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>ThinkPHP 解决跨越问题</title>
    <link href="http://yoursite.com/2019/03/29/19-03/2019-3-29/"/>
    <id>http://yoursite.com/2019/03/29/19-03/2019-3-29/</id>
    <published>2019-03-29T10:05:03.000Z</published>
    <updated>2019-03-29T10:16:18.128Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThinkPHP-解决跨越问题"><a href="#ThinkPHP-解决跨越问题" class="headerlink" title="ThinkPHP 解决跨越问题"></a>ThinkPHP 解决跨越问题</h3><ol><li>首先在 application目录下的tags.php中找到 app_init，并将其修改为下面的样子<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册解决跨域的类:</span><br><span class="line">     &apos;app_init&apos;     =&gt; [</span><br><span class="line">        &apos;app\\index\\behavior\\CORS&apos;</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li>在application-&gt;index目录下新建behavior文件夹-&gt;CORS.php，将下面这段代码复制进去<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * Created by PhpStorm.</span><br><span class="line"> * User: Gaoy</span><br><span class="line"> * Date: 2017/12/22</span><br><span class="line"> * Time: 16:13</span><br><span class="line"> */</span><br><span class="line">namespace app\index\behavior;</span><br><span class="line"></span><br><span class="line">use think\Response;</span><br><span class="line"></span><br><span class="line">class CORS &#123;</span><br><span class="line"></span><br><span class="line">    public function appInit()&#123;</span><br><span class="line">        header(&apos;Access-Control-Allow-Origin: *&apos;);</span><br><span class="line">        header(&quot;Access-Control-Allow-Headers: token, Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;);</span><br><span class="line">        header(&apos;Access-Control-Allow-Methods: POST,GET,PUT,DELETE&apos;);</span><br><span class="line"></span><br><span class="line">        if(request()-&gt;isOptions())&#123;</span><br><span class="line">            exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>╮(╯▽╰)╭ 大工告成，果然还是后台来做跨越简单，jsonp什么的果然弱到爆。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ThinkPHP-解决跨越问题&quot;&gt;&lt;a href=&quot;#ThinkPHP-解决跨越问题&quot; class=&quot;headerlink&quot; title=&quot;ThinkPHP 解决跨越问题&quot;&gt;&lt;/a&gt;ThinkPHP 解决跨越问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;首先在 application目录下的tags.php中找到 app_init，并将其修改为下面的样子&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;注册解决跨域的类:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;apos;app_init&amp;apos;     =&amp;gt; [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;apos;app\\index\\behavior\\CORS&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ],&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>vue 多项选择功能</title>
    <link href="http://yoursite.com/2019/03/28/19-03/2019-3-28/"/>
    <id>http://yoursite.com/2019/03/28/19-03/2019-3-28/</id>
    <published>2019-03-28T06:58:03.000Z</published>
    <updated>2019-03-28T06:50:03.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多项选择"><a href="#多项选择" class="headerlink" title="多项选择"></a>多项选择</h3><ol><li>同时可以选中多个， 多选已选中状态再次点击取消选中</li><li>多选选中项的记录，选择几个记录几个，选中再取消时需要将本条记录的数据同时消除<a id="more"></a></li></ol><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">        &lt;h3&gt;问题：&lt;/h3&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li :class=&quot;&#123;cur:arr.indexOf(item.id)&gt;-1&#125;&quot; @click=&quot;addcur(item.id)&quot; v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot; ref=&quot;liId&quot;&gt;&#123;&#123;item.txt&#125;&#125;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">        &lt;div class=&quot;btn&quot; @click=&quot;nextquestion&quot;&gt;下一题&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            list:[</span><br><span class="line">                &#123;id:1,txt:&apos;a第1个&apos;&#125;,</span><br><span class="line">                &#123;id:2,txt:&apos;b第2个&apos;&#125;,</span><br><span class="line">                &#123;id:3,txt:&apos;c第3个&apos;&#125;,</span><br><span class="line">                &#123;id:4,txt:&apos;d第4个&apos;&#125;,</span><br><span class="line">            ],</span><br><span class="line">            arr:[],</span><br><span class="line">            str:&apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><p>选中思路：新建一个数组，判断当前点击元素的id有没有在数组中存在。如果有就删除掉这个id，如果没有，就添加到数组中<br>选中状态：判断点击元素的id是否在新数组中，如果新数组arr中有这个元素的id，就添加选中的类，如果没有就不添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">addcur:function(id)&#123;</span><br><span class="line">                </span><br><span class="line">        let indexd = this.arr.indexOf(id)//点击元素所在的下标</span><br><span class="line">        // 判断数组中是否有点击元素的id，如果有删除掉，如果没有则添加</span><br><span class="line">            if(indexd&gt;-1)&#123;</span><br><span class="line">            this.arr.splice(indexd,1)</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">            this.arr.push(id)</span><br><span class="line">        &#125;</span><br><span class="line">        // console.log(this.arr.join(&quot;&quot;))</span><br><span class="line">        </span><br><span class="line">        console.log(this.arr)</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;多项选择&quot;&gt;&lt;a href=&quot;#多项选择&quot; class=&quot;headerlink&quot; title=&quot;多项选择&quot;&gt;&lt;/a&gt;多项选择&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;同时可以选中多个， 多选已选中状态再次点击取消选中&lt;/li&gt;
&lt;li&gt;多选选中项的记录，选择几个记录几个，选中再取消时需要将本条记录的数据同时消除&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>call()和apply()区别</title>
    <link href="http://yoursite.com/2019/03/27/19-03/2019-3-27/"/>
    <id>http://yoursite.com/2019/03/27/19-03/2019-3-27/</id>
    <published>2019-03-27T02:58:03.000Z</published>
    <updated>2019-03-27T05:51:53.017Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。<br><a id="more"></a></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*apply()方法*/</span><br><span class="line">function.apply(thisObj[, argArray])</span><br><span class="line"></span><br><span class="line">/*call()方法*/</span><br><span class="line">function.call(thisObj[, arg1[, arg2[, [,...argN]]]]);</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>改变执行上下文</p><h4 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h4><p>我们在写一个方法的时候，总是会用到一个关键字this，而this的指向就是我们这里所说的执行上下文（执行环境）</p><p>this指向的永远是调用该方法的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test1()&#123;</span><br><span class="line">        this.num = 1</span><br><span class="line">        console.log(this.num)</span><br><span class="line">    &#125;</span><br><span class="line">test1()//1</span><br></pre></td></tr></table></figure></p><p>上面代码中的test1是全局对象window下的一个方法，那么调用该方法的对象就是全局对象window，所以this的指向对象就应该是window，所以上面打印结果为1<br>在知道什么是执行上下文后，那么改变执行上下文的含义就更好理解了（函数被调用的时候, 查看this 指向哪个object, 那么那个object 就是当前的 “上下文”。按照江湖流传的说法，就是改变this指向）</p><h4 id="改变执行上下文的意义"><a href="#改变执行上下文的意义" class="headerlink" title="改变执行上下文的意义"></a>改变执行上下文的意义</h4><p>嗯~简单来说，就是为了方便，举个栗子：<br>大壮有一个电热锅，大壮的小伙伴二狗子今天想吃火锅，但二狗子没有电热锅，他又不想为吃一顿火锅再去买个电热锅，于是就借用了大壮的电热锅，这样既可以达到目的，又节省了开支，一举两得</p><p>改变执行上下文也是一样，A对象有一个方法，而B对象因为某种原因也需要用到一样的方法，那么这时候我们去借用A的方法远比再给B扩展一个同样的方法来的要划算，既可以完成需求，又能减少内存的占用，何乐而不为</p><h4 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h4><ol><li><p>相同点：都能够改变方法的执行上下文（执行环境），将一个对象的方法交给另一个对象来执行，并且是立即执行</p></li><li><p>不同点<br>call方法从第二个参数开始可以接收任意个参数，每个参数会映射到相应位置的func的参数上，可以通过参数名调用，但是如果将所有的参数作为数组传入，它们会作为一个整体映射到func对应的第一个参数上，之后参数都为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test (a,b,c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">test.call(obj, 1,2,3)</span><br><span class="line">// function接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">test.call(obj, [1,2,3])</span><br><span class="line">// function接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure></li></ol><p>apply方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入test中，并且会被映射到test对应的参数上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test.apply(obj, [1,2,3])</span><br><span class="line">// function接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">test.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">// function接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure></p><h4 id="用途-对象继承"><a href="#用途-对象继承" class="headerlink" title="用途:对象继承"></a>用途:对象继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;</span><br><span class="line">    this.num = 1</span><br><span class="line">    this.sun = function()&#123;</span><br><span class="line">        console.log(this.num+1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function son()&#123;</span><br><span class="line">    parent.call(this)//将this指向parent函数，继承parent内的方法和变量</span><br><span class="line">    this.sun()</span><br><span class="line">&#125;</span><br><span class="line">son()//2</span><br></pre></td></tr></table></figure><p>son通过call方法，继承了parent的sun方法和num变量，同时son还可以扩展自己的其他方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function son()&#123;</span><br><span class="line">        parent.call(this)//将this指向parent函数，继承parent内的方法和变量</span><br><span class="line">        this.sun()</span><br><span class="line">        this.p = 5</span><br><span class="line">        this.fox = function()&#123;//son自己的方法</span><br><span class="line">            console.log(this.p+3)</span><br><span class="line">        &#125;</span><br><span class="line">        fox()</span><br><span class="line">    &#125;</span><br><span class="line">    son()//2 8</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。&lt;/p&gt;
&lt;p&gt;call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>this关键字指向</title>
    <link href="http://yoursite.com/2019/03/25/19-03/2019-3-25/"/>
    <id>http://yoursite.com/2019/03/25/19-03/2019-3-25/</id>
    <published>2019-03-25T06:24:00.000Z</published>
    <updated>2019-03-27T05:50:06.154Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一篇掘金上关于this的文章，感觉写的很好，在此记录一下，方便日后查看<br><a href="https://juejin.im/post/5c96d0c751882511c832ff7b" target="_blank" rel="noopener">传送门@前端小姐姐</a></p><h3 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h3><p>this是什么？首先记住this不是指向自身！this 就是一个指针，指向调用函数的对象<br><a id="more"></a></p><h4 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h4><ol><li>默认绑定</li><li>隐式绑定</li><li>硬绑定</li><li>new绑定</li></ol><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;YvetteLau&apos;;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure></p><p>在调用Hi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。<br>上面的代码，如果在浏览器环境中运行，那么结果就是 Hello,YvetteLau<br>但是如果在node环境中运行，结果就是 Hello,undefined.这是因为node中name并不是挂在全局对象上的。<br>本文中，如不特殊说明，默认为浏览器环境执行结果。</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun().我们来看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">person.sayHi();</span><br></pre></td></tr></table></figure></p><p>打印的结果是 Hello,YvetteLau.<br>sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person）<br>需要注意的是：对象属性链中只有最后一层会影响到调用位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    name: &apos;Christina&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    friend: person2</span><br><span class="line">&#125;</span><br><span class="line">person1.friend.sayHi();</span><br></pre></td></tr></table></figure></p><p>因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend。</p><p>隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = person.sayHi;</span><br><span class="line">Hi();</span><br></pre></td></tr></table></figure></p><p>结果是: Hello,Wiliam.<br>这是为什么呢，Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢继续这个格式:XXX.fn();fn()前如果什么都没有，那么肯定不是隐式绑定，但是也不一定就是默认绑定，这里有点小疑问，我们后来会说到。<br>除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: function()&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&apos;Hello,&apos;,this.name);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    name: &apos;Christina&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name=&apos;Wiliam&apos;;</span><br><span class="line">person1.sayHi();</span><br><span class="line">setTimeout(person2.sayHi,100);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    person2.sayHi();</span><br><span class="line">&#125;,200);</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Christina</span><br></pre></td></tr></table></figure></p><p>第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象</p><p>第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why?<br>其实这里我们可以这样理解: setTimeout(fn,delay){ fn(); },相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。</p><p>第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系</p><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>显式绑定比较好理解，就是通过call,apply,bind的方式，显式的指定this所指向的对象。(注意:《你不知道的Javascript》中将bind单独作为了硬绑定讲解了)<br>call,apply和bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = person.sayHi;</span><br><span class="line">Hi.call(person); //Hi.apply(person)</span><br></pre></td></tr></table></figure></p><p>输出的结果为: Hello, YvetteLau. 因为使用硬绑定明确将this绑定在了person上。</p><p>那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = function(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure><p>输出的结果是 Hello, Wiliam. 原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，隐式绑定也丢了)，没有指定this的值，对应的是默认绑定。<br>现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它硬绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = function(fn) &#123;</span><br><span class="line">    fn.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure></p><p>此时，输出的结果为: Hello, YvetteLau，因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象</p><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>javaScript和Ｃ＋＋不一样，并没有类，在javaScript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用new来调用函数，会自动执行下面的操作：</span><br></pre></td></tr></table></figure></p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋值给新对象，即this指向这个新对象</li><li>执行构造函数中的代码</li><li>返回新对象<br>因此，我们使用new来调用函数的时候，就会新对象绑定到这个函数的this上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayHi(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var Hi = new sayHi(&apos;Yevtte&apos;);</span><br><span class="line">console.log(&apos;Hello,&apos;, Hi.name);</span><br></pre></td></tr></table></figure><p>输出结果为 Hello, Yevtte, 原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上</p><h4 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h4><p>我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？<br>显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为:<br>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定<br>这个规则时如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可</p><h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><p>凡事都有例外，this的规则也是这样。</p><p>如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind,这些值在调用时会被忽略，实际应用的是默认绑定规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = function(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(null, person.sayHi);</span><br></pre></td></tr></table></figure></p><p>输出的结果是 Hello, Wiliam，因为这时实际应用的是默认绑定规则。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点:<br>（1）函数体内的this对象，继承的是外层代码块的this。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>（5）箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="如何判断this的指向"><a href="#如何判断this的指向" class="headerlink" title="如何判断this的指向"></a>如何判断this的指向</h4><ol><li>函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。</li><li>函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。</li><li>函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo()</li><li>如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。</li><li>如果把Null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li><li>如果是箭头函数，箭头函数的this继承的是外层代码块的this。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一篇掘金上关于this的文章，感觉写的很好，在此记录一下，方便日后查看&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5c96d0c751882511c832ff7b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门@前端小姐姐&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;this是什么&quot;&gt;&lt;a href=&quot;#this是什么&quot; class=&quot;headerlink&quot; title=&quot;this是什么&quot;&gt;&lt;/a&gt;this是什么&lt;/h3&gt;&lt;p&gt;this是什么？首先记住this不是指向自身！this 就是一个指针，指向调用函数的对象&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2019/03/22/19-03/web-2/"/>
    <id>http://yoursite.com/2019/03/22/19-03/web-2/</id>
    <published>2019-03-22T09:45:03.000Z</published>
    <updated>2019-03-27T05:51:28.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念：闭包是函数和声明该函数的词法环境的组合。"><a href="#概念：闭包是函数和声明该函数的词法环境的组合。" class="headerlink" title="概念：闭包是函数和声明该函数的词法环境的组合。"></a>概念：闭包是函数和声明该函数的词法环境的组合。</h3><p>对于闭包的定义大都比较抽象，而我的理解是：闭包就是能够读取其他函数内部变量的函数。<br>由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。<br>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁</p><h3 id="闭包的形式"><a href="#闭包的形式" class="headerlink" title="闭包的形式"></a>闭包的形式</h3><a id="more"></a><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum = function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</span><br></pre></td></tr></table></figure></p><p>用函数f时，才真正计算求和的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(); // 15</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p><p>请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f1 = lazy_sum([1, 2, 3, 4, 5]);</span><br><span class="line">var f2 = lazy_sum([1, 2, 3, 4, 5]);</span><br><span class="line">f1 === f2; // false</span><br></pre></td></tr></table></figure></p><p>f1()和f2()的调用结果互不影响。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用（可理解为：当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量）</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push(function () &#123;</span><br><span class="line">            return i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var results = count();</span><br><span class="line">var f1 = results[0];</span><br><span class="line">var f2 = results[1];</span><br><span class="line">var f3 = results[2]</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。<br>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1(); // 16</span><br><span class="line">f2(); // 16</span><br><span class="line">f3(); // 16</span><br></pre></td></tr></table></figure></p><p>全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。<br>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量</p><p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push((function (n) &#123;</span><br><span class="line">            return function () &#123;</span><br><span class="line">                return n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var results = count();</span><br><span class="line">var f1 = results[0];</span><br><span class="line">var f2 = results[1];</span><br><span class="line">var f3 = results[2];</span><br><span class="line"></span><br><span class="line">f1(); // 1</span><br><span class="line">f2(); // 4</span><br><span class="line">f3(); // 9</span><br></pre></td></tr></table></figure></p><p>说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？</p><p>当然不是！闭包有非常强大的功能。举个栗子：</p><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p><p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function create_counter(initial) &#123;</span><br><span class="line">    var x = initial || 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        inc: function () &#123;</span><br><span class="line">            x += 1;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var c1 = create_counter();</span><br><span class="line">c1.inc(); // 1</span><br><span class="line">c1.inc(); // 2</span><br><span class="line">c1.inc(); // 3</span><br><span class="line"></span><br><span class="line">var c2 = create_counter(10);</span><br><span class="line">c2.inc(); // 11</span><br><span class="line">c2.inc(); // 12</span><br><span class="line">c2.inc(); // 13</span><br></pre></td></tr></table></figure></p><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来</p><p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function make_pow(n) &#123;</span><br><span class="line">    return function (x) &#123;</span><br><span class="line">        return Math.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>// 创建两个新函数:var pow2 = make_pow(2);var pow3 = make_pow(3);console.log(pow2(5)); // 25console.log(pow3(7)); // 343</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念：闭包是函数和声明该函数的词法环境的组合。&quot;&gt;&lt;a href=&quot;#概念：闭包是函数和声明该函数的词法环境的组合。&quot; class=&quot;headerlink&quot; title=&quot;概念：闭包是函数和声明该函数的词法环境的组合。&quot;&gt;&lt;/a&gt;概念：闭包是函数和声明该函数的词法环境的组合。&lt;/h3&gt;&lt;p&gt;对于闭包的定义大都比较抽象，而我的理解是：闭包就是能够读取其他函数内部变量的函数。&lt;br&gt;由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。&lt;br&gt;所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁&lt;/p&gt;
&lt;h3 id=&quot;闭包的形式&quot;&gt;&lt;a href=&quot;#闭包的形式&quot; class=&quot;headerlink&quot; title=&quot;闭包的形式&quot;&gt;&lt;/a&gt;闭包的形式&lt;/h3&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>判断设备类型</title>
    <link href="http://yoursite.com/2019/03/19/19-03/web-1/"/>
    <id>http://yoursite.com/2019/03/19/19-03/web-1/</id>
    <published>2019-03-19T10:08:55.000Z</published>
    <updated>2019-03-27T05:51:25.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断iPhone-X"><a href="#判断iPhone-X" class="headerlink" title="判断iPhone X"></a>判断iPhone X</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 判断iPhone X</span><br><span class="line"></span><br><span class="line">function isIphoneX()&#123;</span><br><span class="line">    return /iphone/gi.test(navigator.userAgent)&amp;&amp;(screen.height == 812 &amp;&amp; screen.width==375)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(function()&#123;</span><br><span class="line">    if(isIphoneX())&#123;</span><br><span class="line">        $(&apos;html&apos;).addClass(&apos;iphonex&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果只是改变样式,在.iPhone X类名下接着写类名+样式即可</span><br><span class="line">.iphonex .wp .middle .middle_text &#123;</span><br><span class="line">    padding-top: 8.925rem;</span><br><span class="line">&#125;</span><br><span class="line">.iphonex .s2_content &#123;</span><br><span class="line">    margin-top: 14.875rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="判断iOS或安卓"><a href="#判断iOS或安卓" class="headerlink" title="判断iOS或安卓"></a>判断iOS或安卓</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//判断iOS或安卓</span><br><span class="line"></span><br><span class="line">$(function () &#123;</span><br><span class="line">    var u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">    var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1; //g</span><br><span class="line">    var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端</span><br><span class="line">    if (isAndroid) &#123;</span><br><span class="line">        alert(&quot;安卓机！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isIOS) &#123;</span><br><span class="line">        alert(&quot;苹果果机！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="判断PC端与WAP端"><a href="#判断PC端与WAP端" class="headerlink" title="判断PC端与WAP端"></a>判断PC端与WAP端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mobile_bs = &#123;</span><br><span class="line"> versions: function() &#123;</span><br><span class="line">  var u = navigator.userAgent;</span><br><span class="line">  return &#123;</span><br><span class="line">   trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核</span><br><span class="line">   presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核</span><br><span class="line">   webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核</span><br><span class="line">   gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核</span><br><span class="line">   mobile: !! u.match(/AppleWebKit.*Mobile.*/) || !! u.match(/AppleWebKit/) &amp;&amp; u.indexOf(&apos;QIHU&apos;) &amp;&amp; u.indexOf(&apos;QIHU&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;Chrome&apos;) &lt; 0, //是否为移动终端</span><br><span class="line">   ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端</span><br><span class="line">   android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或者uc浏览器</span><br><span class="line">   iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;Mac&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器</span><br><span class="line">   iPad: u.indexOf(&apos;iPad&apos;) &gt; -1,  //是否iPad</span><br><span class="line">   webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; ()</span><br><span class="line">&#125;;</span><br><span class="line">if (mobile_bs.versions.mobile) &#123;</span><br><span class="line"> if (mobile_bs.versions.android || mobile_bs.versions.iPhone || mobile_bs.versions.iPad || mobile_bs.versions.ios) &#123;</span><br><span class="line">  window.location.href = &quot;移动端网址&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="js判断当前页面在移动设备还是在PC端中打开"><a href="#js判断当前页面在移动设备还是在PC端中打开" class="headerlink" title="js判断当前页面在移动设备还是在PC端中打开"></a>js判断当前页面在移动设备还是在PC端中打开</h3><p>//js判断当前页面在移动设备还是在PC端中打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var browser = &#123;</span><br><span class="line">             versions: function () &#123;</span><br><span class="line">               var u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">               return &#123;     //移动终端浏览器版本信息</span><br><span class="line">                 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核</span><br><span class="line">                 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核</span><br><span class="line">                 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核</span><br><span class="line">                 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核</span><br><span class="line">                 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端</span><br><span class="line">                 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端</span><br><span class="line">                 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或uc浏览器</span><br><span class="line">                 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器</span><br><span class="line">                 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad</span><br><span class="line">                 webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部</span><br><span class="line">               &#125;;</span><br><span class="line">             &#125;(),</span><br><span class="line">             language: (navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">           &#125;            </span><br><span class="line">           if (browser.versions.mobile) &#123;//判断是否是移动设备打开。browser代码在下面</span><br><span class="line">               var ua = navigator.userAgent.toLowerCase();//获取判断用的对象</span><br><span class="line">               if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123;</span><br><span class="line">                   //在微信中打开</span><br><span class="line">                  setInterval(WeixinJSBridge.call(&apos;closeWindow&apos;),2000);</span><br><span class="line">               &#125;</span><br><span class="line">               if (ua.match(/WeiBo/i) == &quot;weibo&quot;) &#123;</span><br><span class="line">                   //在新浪微博客户端打开</span><br><span class="line">               &#125;</span><br><span class="line">               if (ua.match(/QQ/i) == &quot;qq&quot;) &#123;</span><br><span class="line">                   //在QQ空间打开</span><br><span class="line">               &#125;</span><br><span class="line">               if (browser.versions.ios) &#123;</span><br><span class="line">                   //是否在IOS浏览器打开</span><br><span class="line">               &#125; </span><br><span class="line">               if(browser.versions.android)&#123;</span><br><span class="line">                   //是否在安卓浏览器打开</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //否则就是PC浏览器打开</span><br><span class="line">               window.close();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h3 id="js判断是否为电脑端"><a href="#js判断是否为电脑端" class="headerlink" title="js判断是否为电脑端"></a>js判断是否为电脑端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//js判断是否为电脑端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果返回的是false说明当前操作系统是手机端，如果返回的是true则说明当前的操作系统是电脑端</span><br><span class="line">function IsPC() &#123;</span><br><span class="line">    var userAgentInfo = navigator.userAgent;</span><br><span class="line">    var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,</span><br><span class="line">        &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,</span><br><span class="line">        &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">    var flag = true;</span><br><span class="line">    for (var v = 0; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;判断iPhone-X&quot;&gt;&lt;a href=&quot;#判断iPhone-X&quot; class=&quot;headerlink&quot; title=&quot;判断iPhone X&quot;&gt;&lt;/a&gt;判断iPhone X&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 判断iPhone X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function isIphoneX()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return /iphone/gi.test(navigator.userAgent)&amp;amp;&amp;amp;(screen.height == 812 &amp;amp;&amp;amp; screen.width==375)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(isIphoneX())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $(&amp;apos;html&amp;apos;).addClass(&amp;apos;iphonex&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果只是改变样式,在.iPhone X类名下接着写类名+样式即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.iphonex .wp .middle .middle_text &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    padding-top: 8.925rem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.iphonex .s2_content &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    margin-top: 14.875rem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
</feed>
