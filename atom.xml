<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫气楠楠</title>
  <icon>https://www.gravatar.com/avatar/7124a429c575994ec398d35a1de49b3d</icon>
  <subtitle>记录点滴，分享世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-27T05:45:30.267Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lval</name>
    <email>m1921219654@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>call()和apply()区别</title>
    <link href="http://yoursite.com/2019/03/27/19-04/2019-04-1/"/>
    <id>http://yoursite.com/2019/03/27/19-04/2019-04-1/</id>
    <published>2019-03-27T06:24:00.000Z</published>
    <updated>2019-03-27T05:45:30.267Z</updated>
    
    <content type="html"><![CDATA[<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p>12355556666</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;call&quot;&gt;&lt;a href=&quot;#call&quot; class=&quot;headerlink&quot; title=&quot;call&quot;&gt;&lt;/a&gt;call&lt;/h3&gt;&lt;p&gt;12355556666&lt;/p&gt;

      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>call()和apply()区别</title>
    <link href="http://yoursite.com/2019/03/27/19-04/2019-3-27/"/>
    <id>http://yoursite.com/2019/03/27/19-04/2019-3-27/</id>
    <published>2019-03-27T02:58:03.000Z</published>
    <updated>2019-03-27T05:45:19.388Z</updated>
    
    <content type="html"><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。<br><a id="more"></a></p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*apply()方法*/</span><br><span class="line">function.apply(thisObj[, argArray])</span><br><span class="line"></span><br><span class="line">/*call()方法*/</span><br><span class="line">function.call(thisObj[, arg1[, arg2[, [,...argN]]]]);</span><br></pre></td></tr></table></figure><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>改变执行上下文</p><h4 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h4><p>我们在写一个方法的时候，总是会用到一个关键字this，而this的指向就是我们这里所说的执行上下文（执行环境）</p><p>this指向的永远是调用该方法的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test1()&#123;</span><br><span class="line">        this.num = 1</span><br><span class="line">        console.log(this.num)</span><br><span class="line">    &#125;</span><br><span class="line">test1()//1</span><br></pre></td></tr></table></figure></p><p>上面代码中的test1是全局对象window下的一个方法，那么调用该方法的对象就是全局对象window，所以this的指向对象就应该是window，所以上面打印结果为1<br>在知道什么是执行上下文后，那么改变执行上下文的含义就更好理解了（函数被调用的时候, 查看this 指向哪个object, 那么那个object 就是当前的 “上下文”。按照江湖流传的说法，就是改变this指向）</p><h4 id="改变执行上下文的意义"><a href="#改变执行上下文的意义" class="headerlink" title="改变执行上下文的意义"></a>改变执行上下文的意义</h4><p>嗯~简单来说，就是为了方便，举个栗子：<br>大壮有一个电热锅，大壮的小伙伴二狗子今天想吃火锅，但二狗子没有电热锅，他又不想为吃一顿火锅再去买个电热锅，于是就借用了大壮的电热锅，这样既可以达到目的，又节省了开支，一举两得</p><p>改变执行上下文也是一样，A对象有一个方法，而B对象因为某种原因也需要用到一样的方法，那么这时候我们去借用A的方法远比再给B扩展一个同样的方法来的要划算，既可以完成需求，又能减少内存的占用，何乐而不为</p><h4 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h4><ol><li><p>相同点：都能够改变方法的执行上下文（执行环境），将一个对象的方法交给另一个对象来执行，并且是立即执行</p></li><li><p>不同点<br>call方法从第二个参数开始可以接收任意个参数，每个参数会映射到相应位置的func的参数上，可以通过参数名调用，但是如果将所有的参数作为数组传入，它们会作为一个整体映射到func对应的第一个参数上，之后参数都为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test (a,b,c) &#123;&#125;</span><br><span class="line"></span><br><span class="line">test.call(obj, 1,2,3)</span><br><span class="line">// function接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">test.call(obj, [1,2,3])</span><br><span class="line">// function接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure></li></ol><p>apply方法最多只有两个参数，第二个参数接收数组或者类数组，但是都会被转换成类数组传入test中，并且会被映射到test对应的参数上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test.apply(obj, [1,2,3])</span><br><span class="line">// function接收到的参数实际上是 1,2,3</span><br><span class="line"></span><br><span class="line">test.apply(obj, &#123;</span><br><span class="line">    0: 1,</span><br><span class="line">    1: 2,</span><br><span class="line">    2: 3,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;)</span><br><span class="line">// function接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure></p><h4 id="用途-对象继承"><a href="#用途-对象继承" class="headerlink" title="用途:对象继承"></a>用途:对象继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function parent()&#123;</span><br><span class="line">    this.num = 1</span><br><span class="line">    this.sun = function()&#123;</span><br><span class="line">        console.log(this.num+1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function son()&#123;</span><br><span class="line">    parent.call(this)//将this指向parent函数，继承parent内的方法和变量</span><br><span class="line">    this.sun()</span><br><span class="line">&#125;</span><br><span class="line">son()//2</span><br></pre></td></tr></table></figure><p>son通过call方法，继承了parent的sun方法和num变量，同时son还可以扩展自己的其他方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function son()&#123;</span><br><span class="line">        parent.call(this)//将this指向parent函数，继承parent内的方法和变量</span><br><span class="line">        this.sun()</span><br><span class="line">        this.p = 5</span><br><span class="line">        this.fox = function()&#123;//son自己的方法</span><br><span class="line">            console.log(this.p+3)</span><br><span class="line">        &#125;</span><br><span class="line">        fox()</span><br><span class="line">    &#125;</span><br><span class="line">    son()//2 8</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h4&gt;&lt;p&gt;apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。&lt;/p&gt;
&lt;p&gt;call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>this关键字指向</title>
    <link href="http://yoursite.com/2019/03/25/2019-3-25/"/>
    <id>http://yoursite.com/2019/03/25/2019-3-25/</id>
    <published>2019-03-25T06:24:00.000Z</published>
    <updated>2019-03-25T06:48:55.129Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一篇掘金上关于this的文章，感觉写的很好，在此记录一下，方便日后查看<br><a href="https://juejin.im/post/5c96d0c751882511c832ff7b" target="_blank" rel="noopener">传送门@前端小姐姐</a></p><h3 id="this是什么"><a href="#this是什么" class="headerlink" title="this是什么"></a>this是什么</h3><p>this是什么？首先记住this不是指向自身！this 就是一个指针，指向调用函数的对象<br><a id="more"></a></p><h4 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h4><ol><li>默认绑定</li><li>隐式绑定</li><li>硬绑定</li><li>new绑定</li></ol><h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>默认绑定，在不能应用其它绑定规则时使用的默认规则，通常是独立函数调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;YvetteLau&apos;;</span><br><span class="line">sayHi();</span><br></pre></td></tr></table></figure></p><p>在调用Hi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。<br>上面的代码，如果在浏览器环境中运行，那么结果就是 Hello,YvetteLau<br>但是如果在node环境中运行，结果就是 Hello,undefined.这是因为node中name并不是挂在全局对象上的。<br>本文中，如不特殊说明，默认为浏览器环境执行结果。</p><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun().我们来看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">person.sayHi();</span><br></pre></td></tr></table></figure></p><p>打印的结果是 Hello,YvetteLau.<br>sayHi函数声明在外部，严格来说并不属于person，但是在调用sayHi时,调用位置会使用person的上下文来引用函数，隐式绑定会把函数调用中的this(即此例sayHi函数中的this)绑定到这个上下文对象（即此例中的person）<br>需要注意的是：对象属性链中只有最后一层会影响到调用位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    name: &apos;Christina&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    friend: person2</span><br><span class="line">&#125;</span><br><span class="line">person1.friend.sayHi();</span><br></pre></td></tr></table></figure></p><p>因为只有最后一层会确定this指向的是什么，不管有多少层，在判断this的时候，我们只关注最后一层，即此处的friend。</p><p>隐式绑定有一个大陷阱，绑定很容易丢失(或者说容易给我们造成误导，我们以为this指向的是什么，但是实际上并非如此).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = person.sayHi;</span><br><span class="line">Hi();</span><br></pre></td></tr></table></figure></p><p>结果是: Hello,Wiliam.<br>这是为什么呢，Hi直接指向了sayHi的引用，在调用的时候，跟person没有半毛钱的关系，针对此类问题，我建议大家只需牢牢继续这个格式:XXX.fn();fn()前如果什么都没有，那么肯定不是隐式绑定，但是也不一定就是默认绑定，这里有点小疑问，我们后来会说到。<br>除了上面这种丢失之外，隐式绑定的丢失是发生在回调函数中(事件回调也是其中一种)，我们来看下面一个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person1 = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: function()&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&apos;Hello,&apos;,this.name);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person2 = &#123;</span><br><span class="line">    name: &apos;Christina&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name=&apos;Wiliam&apos;;</span><br><span class="line">person1.sayHi();</span><br><span class="line">setTimeout(person2.sayHi,100);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    person2.sayHi();</span><br><span class="line">&#125;,200);</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Wiliam</span><br><span class="line">Hello, Christina</span><br></pre></td></tr></table></figure></p><p>第一条输出很容易理解，setTimeout的回调函数中，this使用的是默认绑定，非严格模式下，执行的是全局对象</p><p>第二条输出是不是有点迷惑了？说好XXX.fun()的时候，fun中的this指向的是XXX呢，为什么这次却不是这样了！Why?<br>其实这里我们可以这样理解: setTimeout(fn,delay){ fn(); },相当于是将person2.sayHi赋值给了一个变量，最后执行了变量，这个时候，sayHi中的this显然和person2就没有关系了。</p><p>第三条虽然也是在setTimeout的回调中，但是我们可以看出，这是执行的是person2.sayHi()使用的是隐式绑定，因此这是this指向的是person2，跟当前的作用域没有任何关系</p><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>显式绑定比较好理解，就是通过call,apply,bind的方式，显式的指定this所指向的对象。(注意:《你不知道的Javascript》中将bind单独作为了硬绑定讲解了)<br>call,apply和bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = person.sayHi;</span><br><span class="line">Hi.call(person); //Hi.apply(person)</span><br></pre></td></tr></table></figure></p><p>输出的结果为: Hello, YvetteLau. 因为使用硬绑定明确将this绑定在了person上。</p><p>那么，使用了硬绑定，是不是意味着不会出现隐式绑定所遇到的绑定丢失呢？显然不是这样的，不信，继续往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = function(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure><p>输出的结果是 Hello, Wiliam. 原因很简单，Hi.call(person, person.sayHi)的确是将this绑定到Hi中的this了。但是在执行fn的时候，相当于直接调用了sayHi方法(记住: person.sayHi已经被赋值给fn了，隐式绑定也丢了)，没有指定this的值，对应的是默认绑定。<br>现在，我们希望绑定不会丢失，要怎么做？很简单，调用fn的时候，也给它硬绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = function(fn) &#123;</span><br><span class="line">    fn.call(this);</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(person, person.sayHi);</span><br></pre></td></tr></table></figure></p><p>此时，输出的结果为: Hello, YvetteLau，因为person被绑定到Hi函数中的this上，fn又将这个对象绑定给了sayHi的函数。这时，sayHi中的this指向的就是person对象</p><h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p>javaScript和Ｃ＋＋不一样，并没有类，在javaScript中，构造函数只是使用new操作符时被调用的函数，这些函数和普通的函数并没有什么不同，它不属于某个类，也不可能实例化出一个类。任何一个函数都可以使用new来调用，因此其实并不存在构造函数，而只有对于函数的“构造调用”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用new来调用函数，会自动执行下面的操作：</span><br></pre></td></tr></table></figure></p><ol><li>创建一个新对象</li><li>将构造函数的作用域赋值给新对象，即this指向这个新对象</li><li>执行构造函数中的代码</li><li>返回新对象<br>因此，我们使用new来调用函数的时候，就会新对象绑定到这个函数的this上</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sayHi(name)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var Hi = new sayHi(&apos;Yevtte&apos;);</span><br><span class="line">console.log(&apos;Hello,&apos;, Hi.name);</span><br></pre></td></tr></table></figure><p>输出结果为 Hello, Yevtte, 原因是因为在var Hi = new sayHi(‘Yevtte’);这一步，会将sayHi中的this绑定到Hi对象上</p><h4 id="绑定优先级"><a href="#绑定优先级" class="headerlink" title="绑定优先级"></a>绑定优先级</h4><p>我们知道了this有四种绑定规则，但是如果同时应用了多种规则，怎么办？<br>显然，我们需要了解哪一种绑定方式的优先级更高，这四种绑定的优先级为:<br>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定<br>这个规则时如何得到的，大家如果有兴趣，可以自己写个demo去测试，或者记住上面的结论即可</p><h4 id="绑定例外"><a href="#绑定例外" class="headerlink" title="绑定例外"></a>绑定例外</h4><p>凡事都有例外，this的规则也是这样。</p><p>如果我们将null或者是undefined作为this的绑定对象传入call、apply或者是bind,这些值在调用时会被忽略，实际应用的是默认绑定规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sayHi()&#123;</span><br><span class="line">    console.log(&apos;Hello,&apos;, this.name);</span><br><span class="line">&#125;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &apos;YvetteLau&apos;,</span><br><span class="line">    sayHi: sayHi</span><br><span class="line">&#125;</span><br><span class="line">var name = &apos;Wiliam&apos;;</span><br><span class="line">var Hi = function(fn) &#123;</span><br><span class="line">    fn();</span><br><span class="line">&#125;</span><br><span class="line">Hi.call(null, person.sayHi);</span><br></pre></td></tr></table></figure></p><p>输出的结果是 Hello, Wiliam，因为这时实际应用的是默认绑定规则。</p><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用时，需要注意以下几点:<br>（1）函数体内的this对象，继承的是外层代码块的this。<br>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。<br>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。<br>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。<br>（5）箭头函数没有自己的this，所以不能用call()、apply()、bind()这些方法去改变this的指向</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="如何判断this的指向"><a href="#如何判断this的指向" class="headerlink" title="如何判断this的指向"></a>如何判断this的指向</h4><ol><li>函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。</li><li>函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。</li><li>函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo()</li><li>如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。</li><li>如果把Null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li><li>如果是箭头函数，箭头函数的this继承的是外层代码块的this。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了一篇掘金上关于this的文章，感觉写的很好，在此记录一下，方便日后查看&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5c96d0c751882511c832ff7b&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门@前端小姐姐&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;this是什么&quot;&gt;&lt;a href=&quot;#this是什么&quot; class=&quot;headerlink&quot; title=&quot;this是什么&quot;&gt;&lt;/a&gt;this是什么&lt;/h3&gt;&lt;p&gt;this是什么？首先记住this不是指向自身！this 就是一个指针，指向调用函数的对象&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>闭包</title>
    <link href="http://yoursite.com/2019/03/22/web-2/"/>
    <id>http://yoursite.com/2019/03/22/web-2/</id>
    <published>2019-03-22T09:45:03.000Z</published>
    <updated>2019-03-25T06:49:03.975Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念：闭包是函数和声明该函数的词法环境的组合。"><a href="#概念：闭包是函数和声明该函数的词法环境的组合。" class="headerlink" title="概念：闭包是函数和声明该函数的词法环境的组合。"></a>概念：闭包是函数和声明该函数的词法环境的组合。</h3><p>对于闭包的定义大都比较抽象，而我的理解是：闭包就是能够读取其他函数内部变量的函数。<br>由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。<br>所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁</p><h3 id="闭包的形式"><a href="#闭包的形式" class="headerlink" title="闭包的形式"></a>闭包的形式</h3><a id="more"></a><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function lazy_sum(arr) &#123;</span><br><span class="line">    var sum = function () &#123;</span><br><span class="line">        return arr.reduce(function (x, y) &#123;</span><br><span class="line">            return x + y;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = lazy_sum([1, 2, 3, 4, 5]); // function sum()</span><br></pre></td></tr></table></figure></p><p>用函数f时，才真正计算求和的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(); // 15</span><br></pre></td></tr></table></figure></p><p>在这个例子中，我们在函数lazy_sum中又定义了函数sum，并且，内部函数sum可以引用外部函数lazy_sum的参数和局部变量，当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。</p><p>请再注意一点，当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f1 = lazy_sum([1, 2, 3, 4, 5]);</span><br><span class="line">var f2 = lazy_sum([1, 2, 3, 4, 5]);</span><br><span class="line">f1 === f2; // false</span><br></pre></td></tr></table></figure></p><p>f1()和f2()的调用结果互不影响。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用（可理解为：当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量）</p><p>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push(function () &#123;</span><br><span class="line">            return i * i;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var results = count();</span><br><span class="line">var f1 = results[0];</span><br><span class="line">var f2 = results[1];</span><br><span class="line">var f3 = results[2]</span><br></pre></td></tr></table></figure></p><p>在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。<br>你可能认为调用f1()，f2()和f3()结果应该是1，4，9，但实际结果是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1(); // 16</span><br><span class="line">f2(); // 16</span><br><span class="line">f3(); // 16</span><br></pre></td></tr></table></figure></p><p>全部都是16！原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。<br>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量</p><p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function count() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    for (var i=1; i&lt;=3; i++) &#123;</span><br><span class="line">        arr.push((function (n) &#123;</span><br><span class="line">            return function () &#123;</span><br><span class="line">                return n * n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(i));</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var results = count();</span><br><span class="line">var f1 = results[0];</span><br><span class="line">var f2 = results[1];</span><br><span class="line">var f3 = results[2];</span><br><span class="line"></span><br><span class="line">f1(); // 1</span><br><span class="line">f2(); // 4</span><br><span class="line">f3(); // 9</span><br></pre></td></tr></table></figure></p><p>说了这么多，难道闭包就是为了返回一个函数然后延迟执行吗？</p><p>当然不是！闭包有非常强大的功能。举个栗子：</p><p>在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用private修饰一个成员变量。</p><p>在没有class机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function create_counter(initial) &#123;</span><br><span class="line">    var x = initial || 0;</span><br><span class="line">    return &#123;</span><br><span class="line">        inc: function () &#123;</span><br><span class="line">            x += 1;</span><br><span class="line">            return x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它用起来像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var c1 = create_counter();</span><br><span class="line">c1.inc(); // 1</span><br><span class="line">c1.inc(); // 2</span><br><span class="line">c1.inc(); // 3</span><br><span class="line"></span><br><span class="line">var c2 = create_counter(10);</span><br><span class="line">c2.inc(); // 11</span><br><span class="line">c2.inc(); // 12</span><br><span class="line">c2.inc(); // 13</span><br></pre></td></tr></table></figure></p><p>在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来</p><p>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用Math.pow(x, y)函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数pow2和pow3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function make_pow(n) &#123;</span><br><span class="line">    return function (x) &#123;</span><br><span class="line">        return Math.pow(x, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>// 创建两个新函数:var pow2 = make_pow(2);var pow3 = make_pow(3);console.log(pow2(5)); // 25console.log(pow3(7)); // 343</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概念：闭包是函数和声明该函数的词法环境的组合。&quot;&gt;&lt;a href=&quot;#概念：闭包是函数和声明该函数的词法环境的组合。&quot; class=&quot;headerlink&quot; title=&quot;概念：闭包是函数和声明该函数的词法环境的组合。&quot;&gt;&lt;/a&gt;概念：闭包是函数和声明该函数的词法环境的组合。&lt;/h3&gt;&lt;p&gt;对于闭包的定义大都比较抽象，而我的理解是：闭包就是能够读取其他函数内部变量的函数。&lt;br&gt;由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。&lt;br&gt;所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁&lt;/p&gt;
&lt;h3 id=&quot;闭包的形式&quot;&gt;&lt;a href=&quot;#闭包的形式&quot; class=&quot;headerlink&quot; title=&quot;闭包的形式&quot;&gt;&lt;/a&gt;闭包的形式&lt;/h3&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>判断设备类型</title>
    <link href="http://yoursite.com/2019/03/19/web-1/"/>
    <id>http://yoursite.com/2019/03/19/web-1/</id>
    <published>2019-03-19T10:08:55.000Z</published>
    <updated>2019-03-19T10:12:39.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断iPhone-X"><a href="#判断iPhone-X" class="headerlink" title="判断iPhone X"></a>判断iPhone X</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 判断iPhone X</span><br><span class="line"></span><br><span class="line">function isIphoneX()&#123;</span><br><span class="line">    return /iphone/gi.test(navigator.userAgent)&amp;&amp;(screen.height == 812 &amp;&amp; screen.width==375)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(function()&#123;</span><br><span class="line">    if(isIphoneX())&#123;</span><br><span class="line">        $(&apos;html&apos;).addClass(&apos;iphonex&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果只是改变样式,在.iPhone X类名下接着写类名+样式即可</span><br><span class="line">.iphonex .wp .middle .middle_text &#123;</span><br><span class="line">    padding-top: 8.925rem;</span><br><span class="line">&#125;</span><br><span class="line">.iphonex .s2_content &#123;</span><br><span class="line">    margin-top: 14.875rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="判断iOS或安卓"><a href="#判断iOS或安卓" class="headerlink" title="判断iOS或安卓"></a>判断iOS或安卓</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//判断iOS或安卓</span><br><span class="line"></span><br><span class="line">$(function () &#123;</span><br><span class="line">    var u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">    var isAndroid = u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1; //g</span><br><span class="line">    var isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); //ios终端</span><br><span class="line">    if (isAndroid) &#123;</span><br><span class="line">        alert(&quot;安卓机！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isIOS) &#123;</span><br><span class="line">        alert(&quot;苹果果机！&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="判断PC端与WAP端"><a href="#判断PC端与WAP端" class="headerlink" title="判断PC端与WAP端"></a>判断PC端与WAP端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var mobile_bs = &#123;</span><br><span class="line"> versions: function() &#123;</span><br><span class="line">  var u = navigator.userAgent;</span><br><span class="line">  return &#123;</span><br><span class="line">   trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核</span><br><span class="line">   presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核</span><br><span class="line">   webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核</span><br><span class="line">   gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核</span><br><span class="line">   mobile: !! u.match(/AppleWebKit.*Mobile.*/) || !! u.match(/AppleWebKit/) &amp;&amp; u.indexOf(&apos;QIHU&apos;) &amp;&amp; u.indexOf(&apos;QIHU&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;Chrome&apos;) &lt; 0, //是否为移动终端</span><br><span class="line">   ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端</span><br><span class="line">   android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或者uc浏览器</span><br><span class="line">   iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1 || u.indexOf(&apos;Mac&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器</span><br><span class="line">   iPad: u.indexOf(&apos;iPad&apos;) &gt; -1,  //是否iPad</span><br><span class="line">   webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; ()</span><br><span class="line">&#125;;</span><br><span class="line">if (mobile_bs.versions.mobile) &#123;</span><br><span class="line"> if (mobile_bs.versions.android || mobile_bs.versions.iPhone || mobile_bs.versions.iPad || mobile_bs.versions.ios) &#123;</span><br><span class="line">  window.location.href = &quot;移动端网址&quot;;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="js判断当前页面在移动设备还是在PC端中打开"><a href="#js判断当前页面在移动设备还是在PC端中打开" class="headerlink" title="js判断当前页面在移动设备还是在PC端中打开"></a>js判断当前页面在移动设备还是在PC端中打开</h3><p>//js判断当前页面在移动设备还是在PC端中打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">var browser = &#123;</span><br><span class="line">             versions: function () &#123;</span><br><span class="line">               var u = navigator.userAgent, app = navigator.appVersion;</span><br><span class="line">               return &#123;     //移动终端浏览器版本信息</span><br><span class="line">                 trident: u.indexOf(&apos;Trident&apos;) &gt; -1, //IE内核</span><br><span class="line">                 presto: u.indexOf(&apos;Presto&apos;) &gt; -1, //opera内核</span><br><span class="line">                 webKit: u.indexOf(&apos;AppleWebKit&apos;) &gt; -1, //苹果、谷歌内核</span><br><span class="line">                 gecko: u.indexOf(&apos;Gecko&apos;) &gt; -1 &amp;&amp; u.indexOf(&apos;KHTML&apos;) == -1, //火狐内核</span><br><span class="line">                 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端</span><br><span class="line">                 ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端</span><br><span class="line">                 android: u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1, //android终端或uc浏览器</span><br><span class="line">                 iPhone: u.indexOf(&apos;iPhone&apos;) &gt; -1, //是否为iPhone或者QQHD浏览器</span><br><span class="line">                 iPad: u.indexOf(&apos;iPad&apos;) &gt; -1, //是否iPad</span><br><span class="line">                 webApp: u.indexOf(&apos;Safari&apos;) == -1 //是否web应该程序，没有头部与底部</span><br><span class="line">               &#125;;</span><br><span class="line">             &#125;(),</span><br><span class="line">             language: (navigator.browserLanguage || navigator.language).toLowerCase()</span><br><span class="line">           &#125;            </span><br><span class="line">           if (browser.versions.mobile) &#123;//判断是否是移动设备打开。browser代码在下面</span><br><span class="line">               var ua = navigator.userAgent.toLowerCase();//获取判断用的对象</span><br><span class="line">               if (ua.match(/MicroMessenger/i) == &quot;micromessenger&quot;) &#123;</span><br><span class="line">                   //在微信中打开</span><br><span class="line">                  setInterval(WeixinJSBridge.call(&apos;closeWindow&apos;),2000);</span><br><span class="line">               &#125;</span><br><span class="line">               if (ua.match(/WeiBo/i) == &quot;weibo&quot;) &#123;</span><br><span class="line">                   //在新浪微博客户端打开</span><br><span class="line">               &#125;</span><br><span class="line">               if (ua.match(/QQ/i) == &quot;qq&quot;) &#123;</span><br><span class="line">                   //在QQ空间打开</span><br><span class="line">               &#125;</span><br><span class="line">               if (browser.versions.ios) &#123;</span><br><span class="line">                   //是否在IOS浏览器打开</span><br><span class="line">               &#125; </span><br><span class="line">               if(browser.versions.android)&#123;</span><br><span class="line">                   //是否在安卓浏览器打开</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //否则就是PC浏览器打开</span><br><span class="line">               window.close();</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h3 id="js判断是否为电脑端"><a href="#js判断是否为电脑端" class="headerlink" title="js判断是否为电脑端"></a>js判断是否为电脑端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//js判断是否为电脑端</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//如果返回的是false说明当前操作系统是手机端，如果返回的是true则说明当前的操作系统是电脑端</span><br><span class="line">function IsPC() &#123;</span><br><span class="line">    var userAgentInfo = navigator.userAgent;</span><br><span class="line">    var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,</span><br><span class="line">        &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,</span><br><span class="line">        &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class="line">    var flag = true;</span><br><span class="line">    for (var v = 0; v &lt; Agents.length; v++) &#123;</span><br><span class="line">        if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;</span><br><span class="line">            flag = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;判断iPhone-X&quot;&gt;&lt;a href=&quot;#判断iPhone-X&quot; class=&quot;headerlink&quot; title=&quot;判断iPhone X&quot;&gt;&lt;/a&gt;判断iPhone X&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 判断iPhone X&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function isIphoneX()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return /iphone/gi.test(navigator.userAgent)&amp;amp;&amp;amp;(screen.height == 812 &amp;amp;&amp;amp; screen.width==375)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(isIphoneX())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $(&amp;apos;html&amp;apos;).addClass(&amp;apos;iphonex&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果只是改变样式,在.iPhone X类名下接着写类名+样式即可&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.iphonex .wp .middle .middle_text &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    padding-top: 8.925rem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.iphonex .s2_content &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    margin-top: 14.875rem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>js常见数组的方法及高阶函数</title>
    <link href="http://yoursite.com/2019/03/18/web/"/>
    <id>http://yoursite.com/2019/03/18/web/</id>
    <published>2019-03-18T08:40:18.000Z</published>
    <updated>2019-03-18T06:14:00.790Z</updated>
    
    <content type="html"><![CDATA[<h3 id="forEach的用法"><a href="#forEach的用法" class="headerlink" title="forEach的用法"></a>forEach的用法</h3><p> 一般数据遍历方法<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5,6,7];  </span><br><span class="line"> for (var i = 0; i &lt; array.length; i) &#123;  </span><br><span class="line">     console.log(i,array[i]);  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>for in 方法遍历数组<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let index in array) &#123;  </span><br><span class="line">    console.log(index,array[index]);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>forEach 方法遍历数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array.forEach（function(v,i,arr)&#123;  </span><br><span class="line">    console.log(v);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>语法：array.forEach(function(v, i, arr), thisValue)<br>上述代码中第一个参数v代表当前元素，第二个参数i代表当前元素的索引（可选），第三个参数arr代表当前元素所属的数组对象（可选）</p><p>thisValue 可选。传递给函数的值一般用 “this” 值。<br>如果这个参数为空， “undefined” 会传递给 “this” 值</p><p>特点：<br> forEach() 方法对数组的每个元素执行一次提供的函数。总是返回undefined；<br> forEach() 方法会改变原数组</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var array1 = [1,2,3,4,5];</span><br><span class="line"> </span><br><span class="line"> varp = array1.forEach(function(value,index)&#123;</span><br><span class="line"> </span><br><span class="line">    console.log(value);   //可遍历到所有数组元素</span><br><span class="line"> </span><br><span class="line">    return value + 10</span><br><span class="line">&#125;);</span><br><span class="line">console.log(p);   //undefined    无论怎样，总返回undefined</span><br></pre></td></tr></table></figure><h3 id="map-方法"><a href="#map-方法" class="headerlink" title="map 方法"></a>map 方法</h3><p>语法：<br>和forEach一样<br>array.map(function(currentValue,index,arr), thisValue)<br>第一个参数v代表当前元素，第二个参数i代表当前元素的索引（可选），第三个参数arr代表当前元素所属的数组对象（可选）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p1 = array1.map(function(value,index)&#123;</span><br><span class="line"> </span><br><span class="line">    console.log(value);   //可遍历到所有数组元素</span><br><span class="line"> </span><br><span class="line">    return value + 10</span><br><span class="line">&#125;);</span><br><span class="line">console.log(p1);   //[11, 12, 13, 14, 15]   返回一个新的数组</span><br></pre></td></tr></table></figure></p><p>不同于forEach的是：<br>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p><p>map() 方法按照原始数组元素顺序依次处理元素。</p><p>注意： map() 不会对空数组进行检测。</p><p>注意： map() 不会改变原始数组。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下的元素。和map()类似，Array的filter()也接收一个函数。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false决定保留还是丢弃该元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：</span><br><span class="line">var arr = [1, 2, 4, 5, 6, 9, 10, 15];</span><br><span class="line">var r = arr.filter(function (x) &#123;</span><br><span class="line">    return x % 2 !== 0;</span><br><span class="line">&#125;);</span><br><span class="line">r; // [1, 5, 9, 15],返回满足过滤条件元素的数组</span><br></pre></td></tr></table></figure></p><p>filter()接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;];</span><br><span class="line">var r = arr.filter(function (element, index, self) &#123;</span><br><span class="line">    console.log(element); // 依次打印&apos;A&apos;, &apos;B&apos;, &apos;C&apos;</span><br><span class="line">    console.log(index); // 依次打印0, 1, 2</span><br><span class="line">    console.log(self); // self就是变量arr</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//利用filter，可以巧妙地去除Array的重复元素：</span><br><span class="line"></span><br><span class="line">var p,</span><br><span class="line">    arr = [&apos;apple&apos;, &apos;strawberry&apos;, &apos;banana&apos;, &apos;pear&apos;, &apos;apple&apos;, &apos;orange&apos;, &apos;orange&apos;, &apos;strawberry&apos;];</span><br><span class="line">    p = arr.filter(function (element, index, self) &#123;</span><br><span class="line">    return self.indexOf(element) === index;</span><br><span class="line">&#125;);</span><br><span class="line">alert(p.toString());</span><br><span class="line">//去除重复元素依靠的是indexOf总是返回第一个元素的位置，后续的重复元素位置与indexOf返回的位置不相等，因此被filter滤掉了。</span><br></pre></td></tr></table></figure></p><h3 id="sort排序算法"><a href="#sort排序算法" class="headerlink" title="sort排序算法"></a>sort排序算法</h3><p>数组的sort()方法默认把所有元素先转换为String再排序，比如’10’排在了’2’的前面，因为字符’1’比字符’2’的ASCII码小。如果使用sort()方法的默认排序规则，直接对数字排序，结果肯定是错误的，<br>但sort()方法也是一个高阶函数，它可以接收一个比较函数来实现自定义的排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//升序排列：</span><br><span class="line">var arr = [10, 20, 30, 1, 2, 3];</span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;); // [1, 2, 3, 10, 20, 30]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//降序排列：</span><br><span class="line">var arr = [10, 20, 30, 1, 2, 3];</span><br><span class="line">arr.sort(function (x, y) &#123;</span><br><span class="line">    if (x &lt; y) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; y) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;); // [30, 20, 10, 3, 2, 1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：</span><br><span class="line">var a1 = [&apos;B&apos;, &apos;A&apos;, &apos;C&apos;];</span><br><span class="line">var a2 = a1.sort();</span><br><span class="line">a1; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">a2; // [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">a1 === a2; // true, a1和a2是同一对象</span><br></pre></td></tr></table></figure></p><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p>定义和用法<br>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</p><p>every() 方法使用指定函数检测数组中的所有元素：</p><p>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。<br>如果所有元素都满足条件，则返回 true</p><p>注意： every() 不会对空数组进行检测。</p><p>注意： every() 不会改变原始数组。</p><p>语法：array.every(function(currentValue,index,arr), thisValue)<br>currentValue    （必须。当前元素的值）<br>index    （可选。当前元素的索引值）<br>arr      （可选。当前元素属于的数组对象）<br>thisValue （可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。<br>如果省略了 thisValue ，”this” 的值为 “undefined”）<br>返回值：布尔值。如果所有元素都通过检测返回 true，否则返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//检测数组内所有元素是否大于10</span><br><span class="line">function isBigEnough(element, index, array) &#123;</span><br><span class="line">  return (element &gt;= 10);</span><br><span class="line">&#125;</span><br><span class="line">var passed = [12, 5, 8, 130, 44].every(isBigEnough);</span><br><span class="line">// passed is false</span><br><span class="line">passed = [12, 54, 18, 130, 44].every(isBigEnough);</span><br><span class="line">// passed is true</span><br></pre></td></tr></table></figure></p><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>定义和用法<br>some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。</p><p>some() 方法会依次执行数组的每个元素：</p><p>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。<br>如果没有满足条件的元素，则返回false。<br>注意： some() 不会对空数组进行检测。</p><p>注意： some() 不会改变原始数组。</p><p>语法：array.some(function(currentValue,index,arr),thisValue) 形式与every相同</p><p>返回值：布尔值。如果数组中有元素满足条件返回 true，否则返回 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//检测数组中是否有大于10的元素</span><br><span class="line">function isBigEnough(element, index, array) &#123;</span><br><span class="line">  return (element &gt;= 10);</span><br><span class="line">&#125;</span><br><span class="line">var passed = [2, 5, 8, 1, 4].some(isBigEnough);</span><br><span class="line">// passed is false</span><br><span class="line">passed = [12, 5, 8, 1, 4].some(isBigEnough);</span><br><span class="line">// passed is true</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;forEach的用法&quot;&gt;&lt;a href=&quot;#forEach的用法&quot; class=&quot;headerlink&quot; title=&quot;forEach的用法&quot;&gt;&lt;/a&gt;forEach的用法&lt;/h3&gt;&lt;p&gt; 一般数据遍历方法&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var array = [1,2,3,4,5,6,7];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; for (var i = 0; i &amp;lt; array.length; i) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     console.log(i,array[i]);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;for in 方法遍历数组&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Promise对象</title>
    <link href="http://yoursite.com/2019/03/14/es6-7/"/>
    <id>http://yoursite.com/2019/03/14/es6-7/</id>
    <published>2019-03-14T03:39:19.000Z</published>
    <updated>2019-03-11T06:31:04.110Z</updated>
    
    <content type="html"><![CDATA[<p>参考自阮老师的ES6入门教程<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="Promise用法"><a href="#Promise用法" class="headerlink" title="Promise用法"></a>Promise用法</h3><p>Promise是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    //做一些异步操作</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        console.log(&apos;执行完成&apos;);</span><br><span class="line">        resolve(&apos;返回的数据&apos;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><a id="more"></a><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。</p><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</p><p>在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。</p><p>运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function runAsync()&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        //做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(&apos;执行完成&apos;);</span><br><span class="line">            resolve(&apos;返回的数据&apos;);</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line">runAsync()</span><br></pre></td></tr></table></figure><p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">runAsync().then(function(data)&#123;</span><br><span class="line">    console.log(data);//返回的数据</span><br><span class="line">    //后面可以用传过来的数据做些其他操作</span><br><span class="line">    //......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“返回的数据”<br>也就是说then里面的函数就跟我们平时的回调函数一个意思（then(function(data)里面的data就是runAsync()成功后返回的数据）</p><h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p>实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。<br>常用于封装请求函数等场景：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 导出一个fetch函数，用来发送请求获取数据 </span><br><span class="line">module.exports = function (url, data) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: `https://locally.xiao.com/$&#123;url&#125;`,</span><br><span class="line">      // 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</span><br><span class="line">      // 模板字符串中嵌入变量，需要将变量名写在$&#123;&#125;之中。</span><br><span class="line">      data,</span><br><span class="line">      success: resolve,</span><br><span class="line">      // success: function (res) &#123;</span><br><span class="line">      //   resolve(res)</span><br><span class="line">      // &#125;,</span><br><span class="line">      fail: reject</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用导出的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetch(&apos;slides&apos;)</span><br><span class="line">      .then(res =&gt; &#123;</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          list: res.data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="reject的用法"><a href="#reject的用法" class="headerlink" title="reject的用法"></a>reject的用法</h3><p>上面用了resolve，接下来开始reject，事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function getNumber(num)&#123;</span><br><span class="line">    var p = new Promise(function(resolve, reject)&#123;</span><br><span class="line">        //做一些异步操作</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            var num = Math.ceil(Math.random()*9); //生成1-9的随机数</span><br><span class="line">            if(num&lt;=5)&#123;</span><br><span class="line">                resolve(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&apos;数字太大了&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 2000);</span><br><span class="line">    &#125;);</span><br><span class="line">    return p;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNumber()</span><br><span class="line">.then(</span><br><span class="line">    function(data)&#123;</span><br><span class="line">        console.log(&apos;resolved&apos;);</span><br><span class="line">        console.log(data);</span><br><span class="line">    &#125;, </span><br><span class="line">    function(reason, data)&#123;</span><br><span class="line">        console.log(&apos;rejected&apos;);</span><br><span class="line">        console.log(reason);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。<br>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果：</p><p>resolved 2 或 rejected 数字太大了</p><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面代码中，fetch方法返回一个 Promise 对象，如果该对象状态变为resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获</p><p>在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getNumber()</span><br><span class="line">.then(function(data)&#123;</span><br><span class="line">    console.log(&apos;resolved&apos;);</span><br><span class="line">    console.log(data);</span><br><span class="line">    console.log(numData); //此处的numData未定义</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function(reason)&#123;</span><br><span class="line">    console.log(&apos;rejected&apos;);</span><br><span class="line">    console.log(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到下面的结果：<br><img src="/2019/03/14/es6-7/01.png" alt="zi"></p><p>也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。</p><h3 id="all的用法"><a href="#all的用法" class="headerlink" title="all的用法"></a>all的用法</h3><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    console.log(&apos;p1&apos;);</span><br><span class="line">    resolve(&apos;p1数据&apos;);</span><br><span class="line">&#125;</span><br><span class="line">let p2 = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    console.log(&apos;p2&apos;);</span><br><span class="line">    resolve(&apos;p2数据&apos;)</span><br><span class="line">&#125;</span><br><span class="line">let p3 = new Promise(function(resolve, reject)&#123;</span><br><span class="line">    console.log(&apos;p3&apos;);</span><br><span class="line">    resolve(&apos;p3数据&apos;)</span><br><span class="line">&#125;</span><br><span class="line">const p = Promise.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure></p><p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例<br>（Promise.all方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Promise</span><br><span class="line">.all([p1, p2, p3])</span><br><span class="line">.then(function(results)&#123;</span><br><span class="line">    console.log(results);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是：<br><code>`</code><br>//p1<br>//p2<br>//p3<br>//[“p1数据”，”p2数据”，”p3数据”]</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考自阮老师的ES6入门教程&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Promise用法&quot;&gt;&lt;a href=&quot;#Promise用法&quot; class=&quot;headerlink&quot; title=&quot;Promise用法&quot;&gt;&lt;/a&gt;Promise用法&lt;/h3&gt;&lt;p&gt;Promise是一个构造函数，自己身上有all、reject、resolve这几个方法，原型上有then、catch等方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var p = new Promise(function(resolve, reject)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //做一些异步操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log(&amp;apos;执行完成&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        resolve(&amp;apos;返回的数据&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;, 2000);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6基础之对象的扩展</title>
    <link href="http://yoursite.com/2019/03/13/es6-5/"/>
    <id>http://yoursite.com/2019/03/13/es6-5/</id>
    <published>2019-03-13T02:19:34.000Z</published>
    <updated>2019-03-11T06:30:48.006Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line">z // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。</p><p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; x, y, ...z &#125; = null; // 运行时错误</span><br><span class="line">let &#123; x, y, ...z &#125; = undefined; // 运行时错误</span><br></pre></td></tr></table></figure></p><p>解构赋值必须是最后一个参数，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123; ...x, y, z &#125; = someObject; // 句法错误</span><br><span class="line">let &#123; x, ...y, ...z &#125; = someObject; // 句法错误</span><br></pre></td></tr></table></figure></p><p>上面代码中，解构赋值不是最后一个参数，所以会报错</p><p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123; a: &#123; b: 1 &#125; &#125;;</span><br><span class="line">let &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = 2;</span><br><span class="line">x.a.b // 2</span><br></pre></td></tr></table></figure></p><p>上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>对象的扩展运算符（…）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let z = &#123; a: 3, b: 4 &#125;;</span><br><span class="line">let n = &#123; ...z &#125;;</span><br><span class="line">n // &#123; a: 3, b: 4 &#125;</span><br></pre></td></tr></table></figure></p><p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#123; ...[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;] &#125;;</span><br><span class="line">foo</span><br><span class="line">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></pre></td></tr></table></figure></p><p>如果扩展运算符后面不是对象，则会自动将其转为对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 &#123;...Object(1)&#125;</span><br><span class="line">&#123;...1&#125; // &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码中，扩展运算符后面是整数1，会自动转为数值的包装对象Number{1}。由于该对象没有自身属性，所以返回一个空对象。</p><p>但是，如果扩展运算符后面是字符串，它会自动转成一个类似数组的对象，因此返回的不是空对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&apos;hello&apos;&#125;</span><br><span class="line">// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象的扩展运算符&quot;&gt;&lt;a href=&quot;#对象的扩展运算符&quot; class=&quot;headerlink&quot; title=&quot;对象的扩展运算符&quot;&gt;&lt;/a&gt;对象的扩展运算符&lt;/h3&gt;&lt;h4 id=&quot;解构赋值&quot;&gt;&lt;a href=&quot;#解构赋值&quot; class=&quot;headerlink&quot; title=&quot;解构赋值&quot;&gt;&lt;/a&gt;解构赋值&lt;/h4&gt;&lt;p&gt;对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6基础之set数据结构</title>
    <link href="http://yoursite.com/2019/03/12/es6-6/"/>
    <id>http://yoursite.com/2019/03/12/es6-6/</id>
    <published>2019-03-12T02:33:40.000Z</published>
    <updated>2019-03-11T03:06:25.904Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值<br><a id="more"></a><br>Set本身是一个构造函数，用来生成 Set 数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const s = new Set();</span><br><span class="line"></span><br><span class="line">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</span><br><span class="line"></span><br><span class="line">for (let i of s) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">// 2 3 5 4</span><br></pre></td></tr></table></figure><p>上面代码通过add()方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p>Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line">const set = new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">// [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</span><br><span class="line">items.size // 5</span><br><span class="line"></span><br><span class="line">// 例三</span><br><span class="line">const set = new Set(document.querySelectorAll(&apos;div&apos;));</span><br><span class="line">set.size // 56</span><br><span class="line"></span><br><span class="line">// 类似于</span><br><span class="line">const set = new Set();</span><br><span class="line">document</span><br><span class="line"> .querySelectorAll(&apos;div&apos;)</span><br><span class="line"> .forEach(div =&gt; set.add(div));</span><br><span class="line">set.size // 56</span><br></pre></td></tr></table></figure></p><p>上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。</p><p>上面代码也展示了一种去除数组重复成员的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 去除数组的重复成员</span><br><span class="line">[...new Set(array)]</span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...new Set(&apos;ababbc&apos;)].join(&apos;&apos;)</span><br><span class="line">// &quot;abc&quot;</span><br></pre></td></tr></table></figure></p><p>向 Set 加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set();</span><br><span class="line">let a = NaN;</span><br><span class="line">let b = NaN;</span><br><span class="line">set.add(a);</span><br><span class="line">set.add(b);</span><br><span class="line">set // Set &#123;NaN&#125;</span><br></pre></td></tr></table></figure><p>上面代码向 Set 实例添加了两个NaN，但是只能加入一个。这表明，在 Set 内部，两个NaN是相等。</p><p>另外，两个对象总是不相等的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set();</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size // 1</span><br><span class="line"></span><br><span class="line">set.add(&#123;&#125;);</span><br><span class="line">set.size // 2</span><br></pre></td></tr></table></figure></p><p>上面代码表示，由于两个空对象不相等，所以它们被视为两个值。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p><p>Set.prototype.constructor：构造函数，默认就是Set函数。<br>Set.prototype.size：返回Set实例的成员总数。<br>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><p>add(value)：添加某个值，返回 Set 结构本身。<br>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。<br>has(value)：返回一个布尔值，表示该值是否为Set的成员。<br>clear()：清除所有成员，没有返回值。</p><p>上面这些属性和方法的实例如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s.add(1).add(2).add(2);</span><br><span class="line">// 注意2被加入了两次</span><br><span class="line"></span><br><span class="line">s.size // 2</span><br><span class="line"></span><br><span class="line">s.has(1) // true</span><br><span class="line">s.has(2) // true</span><br><span class="line">s.has(3) // false</span><br><span class="line"></span><br><span class="line">s.delete(2);</span><br><span class="line">s.has(2) // false</span><br></pre></td></tr></table></figure></p><p>下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 对象的写法</span><br><span class="line">const properties = &#123;</span><br><span class="line">  &apos;width&apos;: 1,</span><br><span class="line">  &apos;height&apos;: 1</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if (properties[someName]) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Set的写法</span><br><span class="line">const properties = new Set();</span><br><span class="line"></span><br><span class="line">properties.add(&apos;width&apos;);</span><br><span class="line">properties.add(&apos;height&apos;);</span><br><span class="line"></span><br><span class="line">if (properties.has(someName)) &#123;</span><br><span class="line">  // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Array.from方法可以将 Set 结构转为数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const items = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">const array = Array.from(items);</span><br></pre></td></tr></table></figure></p><p>这就提供了去除数组重复成员的另一种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function dedupe(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([1, 1, 2, 3]) // [1, 2, 3]</span><br></pre></td></tr></table></figure></p><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><p>keys()：返回键名的遍历器<br>values()：返回键值的遍历器<br>entries()：返回键值对的遍历器<br>forEach()：使用回调函数遍历每个成员</p><p>（1）keys()，values()，entries()<br>keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">for (let item of set.keys()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let item of set.values()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br><span class="line"></span><br><span class="line">for (let item of set.entries()) &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;</span><br><span class="line">// [&quot;red&quot;, &quot;red&quot;]</span><br><span class="line">// [&quot;green&quot;, &quot;green&quot;]</span><br><span class="line">// [&quot;blue&quot;, &quot;blue&quot;]</span><br></pre></td></tr></table></figure></p><p>上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等</p><p>Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set.prototype[Symbol.iterator] === Set.prototype.values</span><br><span class="line">// true</span><br></pre></td></tr></table></figure></p><p>这意味着，可以省略values方法，直接用for…of循环遍历 Set。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line"></span><br><span class="line">for (let x of set) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// red</span><br><span class="line">// green</span><br><span class="line">// blue</span><br></pre></td></tr></table></figure><p>（2）forEach()</p><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 4, 9]);</span><br><span class="line">set.forEach((value, key) =&gt; console.log(key + &apos; : &apos; + value))</span><br><span class="line">// 1 : 1</span><br><span class="line">// 4 : 4</span><br><span class="line">// 9 : 9</span><br></pre></td></tr></table></figure></p><p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</p><p>（3）遍历的应用</p><p>扩展运算符（…）内部使用for…of循环，所以也可以用于 Set 结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]);</span><br><span class="line">let arr = [...set];</span><br><span class="line">// [&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]</span><br></pre></td></tr></table></figure><p>扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let arr = [3, 5, 2, 2, 5, 5];</span><br><span class="line">let unique = [...new Set(arr)];</span><br><span class="line">// [3, 5, 2]</span><br></pre></td></tr></table></figure></p><p>而且，数组的map和filter方法也可以间接用于 Set 了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let set = new Set([1, 2, 3]);</span><br><span class="line">set = new Set([...set].map(x =&gt; x * 2));</span><br><span class="line">// 返回Set结构：&#123;2, 4, 6&#125;</span><br><span class="line"></span><br><span class="line">let set = new Set([1, 2, 3, 4, 5]);</span><br><span class="line">set = new Set([...set].filter(x =&gt; (x % 2) == 0));</span><br><span class="line">// 返回Set结构：&#123;2, 4&#125;</span><br></pre></td></tr></table></figure></p><p>因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// set &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure><p>如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法一</span><br><span class="line">let set = new Set([1, 2, 3]);</span><br><span class="line">set = new Set([...set].map(val =&gt; val * 2));</span><br><span class="line">// set的值是2, 4, 6</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line">let set = new Set([1, 2, 3]);</span><br><span class="line">set = new Set(Array.from(set, val =&gt; val * 2));</span><br><span class="line">// set的值是2, 4, 6</span><br></pre></td></tr></table></figure></p><p>上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6基础之数组的扩展</title>
    <link href="http://yoursite.com/2019/03/11/es6-4/"/>
    <id>http://yoursite.com/2019/03/11/es6-4/</id>
    <published>2019-03-11T07:50:03.000Z</published>
    <updated>2019-03-11T02:53:37.849Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1. 扩展运算符"></a>1. 扩展运算符</h3><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[1, 2, 3])</span><br><span class="line">// 1 2 3</span><br><span class="line"></span><br><span class="line">console.log(1, ...[2, 3, 4], 5)</span><br><span class="line">// 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(&apos;div&apos;)]</span><br><span class="line">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>该运算符主要用于函数调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br></pre></td></tr></table></figure></p><p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">var args = [0, 1, 2];</span><br><span class="line">f.apply(null, args);</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">function f(x, y, z) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">let args = [0, 1, 2];</span><br><span class="line">f(...args)</span><br></pre></td></tr></table></figure></p><p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// ES5 的写法</span><br><span class="line">Math.max.apply(null, [14, 3, 77])</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">Math.max(...[14, 3, 77])</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">Math.max(14, 3, 77);</span><br></pre></td></tr></table></figure></p><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p><p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// ES5的 写法</span><br><span class="line">var arr1 = [0, 1, 2];</span><br><span class="line">var arr2 = [3, 4, 5];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line">// ES6 的写法</span><br><span class="line">let arr1 = [0, 1, 2];</span><br><span class="line">let arr2 = [3, 4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></p><p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法</p><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><ol><li>复制数组<br>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [1, 2];</span><br><span class="line">const a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[0] = 2;</span><br><span class="line">a1 // [2, 2]</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p><ol start="2"><li>合并数组</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [&apos;a&apos;, &apos;b&apos;];</span><br><span class="line">const arr2 = [&apos;c&apos;];</span><br><span class="line">const arr3 = [&apos;d&apos;, &apos;e&apos;];</span><br><span class="line"></span><br><span class="line">// ES5 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br><span class="line"></span><br><span class="line">// ES6 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ]</span><br></pre></td></tr></table></figure><p>两种方法都是浅拷贝，使用的时候需要注意。</p><ol start="3"><li>与解构赋值结合<br>扩展运算符可以与解构赋值结合起来，用于生成数组。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [];</span><br><span class="line">first // undefined</span><br><span class="line">rest  // []</span><br><span class="line"></span><br><span class="line">const [first, ...rest] = [&quot;foo&quot;];</span><br><span class="line">first  // &quot;foo&quot;</span><br><span class="line">rest   // []</span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>字符串<br>扩展运算符还可以将字符串转为真正的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br></pre></td></tr></table></figure></li><li><p>实现了 Iterator 接口的对象<br>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let nodeList = document.querySelectorAll(&apos;div&apos;);</span><br><span class="line">let array = [...nodeList];</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中，querySelectorAll方法返回的是一个NodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p>Array.of方法用于将一组值，转换为数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.of(3, 11, 8) // [3,11,8]</span><br><span class="line">Array.of(3) // [3]</span><br><span class="line">Array.of(3).length // 1</span><br></pre></td></tr></table></figure></p><p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array() // []</span><br><span class="line">Array(3) // [, , ,]</span><br><span class="line">Array(3, 11, 8) // [3, 11, 8]</span><br></pre></td></tr></table></figure></p><p>上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p><h3 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].find(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 10</span><br></pre></td></tr></table></figure><p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 5, 10, 15].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; 9;</span><br><span class="line">&#125;) // 2</span><br></pre></td></tr></table></figure></p><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(v)&#123;</span><br><span class="line">  return v &gt; this.age;</span><br><span class="line">&#125;</span><br><span class="line">let person = &#123;name: &apos;John&apos;, age: 20&#125;;</span><br><span class="line">[10, 12, 26, 15].find(f, person);    // 26</span><br></pre></td></tr></table></figure></p><p>上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。</p><h3 id="数组实例的-fill"><a href="#数组实例的-fill" class="headerlink" title="数组实例的 fill()"></a>数组实例的 fill()</h3><p>fill方法使用给定值，填充一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br></pre></td></tr></table></figure></p><p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p><p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7, 1, 2)</span><br><span class="line">// [&apos;a&apos;, 7, &apos;c&apos;]</span><br></pre></td></tr></table></figure></p><p>上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p><p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = new Array(3).fill(&#123;name: &quot;Mike&quot;&#125;);</span><br><span class="line">arr[0].name = &quot;Ben&quot;;</span><br><span class="line">arr</span><br><span class="line">// [&#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;, &#123;name: &quot;Ben&quot;&#125;]</span><br><span class="line"></span><br><span class="line">let arr = new Array(3).fill([]);</span><br><span class="line">arr[0].push(5);</span><br><span class="line">arr</span><br><span class="line">// [[5], [5], [5]]</span><br></pre></td></tr></table></figure></p><h3 id="数组实例的-entries-，keys-和-values"><a href="#数组实例的-entries-，keys-和-values" class="headerlink" title="数组实例的 entries()，keys() 和 values()"></a>数组实例的 entries()，keys() 和 values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123;</span><br><span class="line">  console.log(index);</span><br><span class="line">&#125;</span><br><span class="line">// 0</span><br><span class="line">// 1</span><br><span class="line"></span><br><span class="line">for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) &#123;</span><br><span class="line">  console.log(elem);</span><br><span class="line">&#125;</span><br><span class="line">// &apos;a&apos;</span><br><span class="line">// &apos;b&apos;</span><br><span class="line"></span><br><span class="line">for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123;</span><br><span class="line">  console.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line">// 0 &quot;a&quot;</span><br><span class="line">// 1 &quot;b&quot;</span><br></pre></td></tr></table></figure></p><h3 id="数组实例的-includes"><a href="#数组实例的-includes" class="headerlink" title="数组实例的 includes()"></a>数组实例的 includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(2)     // true</span><br><span class="line">[1, 2, 3].includes(4)     // false</span><br><span class="line">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure></p><p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].includes(3, 3);  // false</span><br><span class="line">[1, 2, 3].includes(3, -1); // true</span><br></pre></td></tr></table></figure></p><h3 id="数组实例的-flat-，flatMap"><a href="#数组实例的-flat-，flatMap" class="headerlink" title="数组实例的 flat()，flatMap()"></a>数组实例的 flat()，flatMap()</h3><p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, 4]].flat()</span><br><span class="line">// [1, 2, 3, 4]</span><br></pre></td></tr></table></figure></p><p>上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置</p><ol><li>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, [3, [4, 5]]].flat()</span><br><span class="line">// [1, 2, 3, [4, 5]]</span><br><span class="line"></span><br><span class="line">[1, 2, [3, [4, 5]]].flat(2)</span><br><span class="line">// [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></li></ol><p>上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。</p><p>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, [2, [3]]].flat(Infinity)</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure></p><p>如果原数组有空位，flat()方法会跳过空位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, , 4, 5].flat()</span><br><span class="line">// [1, 2, 4, 5]</span><br></pre></td></tr></table></figure></p><ol start="2"><li>flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span><br><span class="line">[2, 3, 4].flatMap((x) =&gt; [x, x * 2])</span><br><span class="line">// [2, 4, 3, 6, 4, 8]</span><br></pre></td></tr></table></figure></li></ol><p>flatMap()只能展开一层数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span><br><span class="line">[1, 2, 3, 4].flatMap(x =&gt; [[x * 2]])</span><br><span class="line">// [[2], [4], [6], [8]]</span><br></pre></td></tr></table></figure></p><p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此flatMap()返回的还是一个嵌套数组。</p><p>flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.flatMap(function callback(currentValue[, index[, array]]) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure></p><p>flatMap()方法还可以有第二个参数，用来绑定遍历函数里面的this。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-扩展运算符&quot;&gt;&lt;a href=&quot;#1-扩展运算符&quot; class=&quot;headerlink&quot; title=&quot;1. 扩展运算符&quot;&gt;&lt;/a&gt;1. 扩展运算符&lt;/h3&gt;&lt;p&gt;扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;console.log(...[1, 2, 3])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 1 2 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(1, ...[2, 3, 4], 5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 1 2 3 4 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[...document.querySelectorAll(&amp;apos;div&amp;apos;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// [&amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;, &amp;lt;div&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6基础之函数的扩展</title>
    <link href="http://yoursite.com/2019/03/10/es6-3/"/>
    <id>http://yoursite.com/2019/03/10/es6-3/</id>
    <published>2019-03-10T06:53:51.000Z</published>
    <updated>2019-03-11T02:53:41.880Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h3><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y) &#123;</span><br><span class="line">  y = y || &apos;World&apos;;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello World</span><br></pre></td></tr></table></figure></p><p>上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值<br><a id="more"></a><br>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure></p><p>注意：参数变量是默认声明的，所以不能用let或const再次声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function foo(x = 5) &#123;</span><br><span class="line">  let x = 1; // error</span><br><span class="line">  const x = 2; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用参数默认值时，函数不能有同名参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 不报错</span><br><span class="line">function foo(x, x, y) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function foo(x, x, y = 1) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line">// SyntaxError: Duplicate parameter name not allowed in this context</span><br></pre></td></tr></table></figure></p><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let x = 99;</span><br><span class="line">function foo(p = x + 1) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() // 100</span><br><span class="line"></span><br><span class="line">x = 100;</span><br><span class="line">foo() // 101</span><br></pre></td></tr></table></figure></p><p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p><h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line"></span><br><span class="line">  for (var val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 3) // 10</span><br></pre></td></tr></table></figure><p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">  items.forEach(function(item) &#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [];</span><br><span class="line">push(a, 1, 2, 3)</span><br></pre></td></tr></table></figure></p><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function f(a, ...b, c) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 允许使用“箭头”（=&gt;）定义函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分<br>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回</p><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125;</span><br></pre></td></tr></table></figure></p><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let getTempItem = id =&gt; &#123; id: id, name: &quot;Temp&quot; &#125;;</span><br><span class="line"></span><br><span class="line">// 不报错</span><br><span class="line">let getTempItem = id =&gt; (&#123; id: id, name: &quot;Temp&quot; &#125;);</span><br></pre></td></tr></table></figure></p><p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let foo = () =&gt; &#123; a: 1 &#125;;</span><br><span class="line">foo() // undefined</span><br></pre></td></tr></table></figure></p><p>上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p><p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数</p><p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure><p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;函数参数默认值&quot;&gt;&lt;a href=&quot;#函数参数默认值&quot; class=&quot;headerlink&quot; title=&quot;函数参数默认值&quot;&gt;&lt;/a&gt;函数参数默认值&lt;/h3&gt;&lt;p&gt;ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;function log(x, y) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  y = y || &amp;apos;World&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(x, y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log(&amp;apos;Hello&amp;apos;) // Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log(&amp;apos;Hello&amp;apos;, &amp;apos;China&amp;apos;) // Hello China&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;log(&amp;apos;Hello&amp;apos;, &amp;apos;&amp;apos;) // Hello World&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6基础之字符串相关扩展</title>
    <link href="http://yoursite.com/2019/03/09/es6-2/"/>
    <id>http://yoursite.com/2019/03/09/es6-2/</id>
    <published>2019-03-09T06:26:48.000Z</published>
    <updated>2019-03-11T02:53:45.786Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口（Iterator接口），使得字符串可以被for…of循环遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (let num of &apos;foo&apos;) &#123;</span><br><span class="line">  console.log(num)</span><br><span class="line">&#125;</span><br><span class="line">// &quot;f&quot;</span><br><span class="line">// &quot;o&quot;</span><br><span class="line">// &quot;o&quot;</span><br></pre></td></tr></table></figure></p><h3 id="includes-startsWith-endsWith"><a href="#includes-startsWith-endsWith" class="headerlink" title="includes(), startsWith(), endsWith()"></a>includes(), startsWith(), endsWith()</h3><a id="more"></a><p>之前JavaScript 只有indexOf方法用来确定一个字符串是否包含在另一个字符串中，ES6 又提供了三种新方法。</p><p>includes()：返回布尔值，表示是否找到了参数字符串。<br>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。<br>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;Hello&apos;) // true</span><br><span class="line">s.endsWith(&apos;!&apos;) // true</span><br><span class="line">s.includes(&apos;o&apos;) // true</span><br></pre></td></tr></table></figure></p><p>这三个方法都支持第二个参数，表示开始搜索的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = &apos;Hello world!&apos;;</span><br><span class="line"></span><br><span class="line">s.startsWith(&apos;world&apos;, 6) // true</span><br><span class="line">s.endsWith(&apos;Hello&apos;, 5) // true</span><br><span class="line">s.includes(&apos;Hello&apos;, 6) // false</span><br></pre></td></tr></table></figure></p><p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.repeat(3) // &quot;xxx&quot;</span><br><span class="line">&apos;hello&apos;.repeat(2) // &quot;hellohello&quot;</span><br><span class="line">&apos;na&apos;.repeat(0) // &quot;&quot;</span><br></pre></td></tr></table></figure></p><p>参数如果是小数，会被取整<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;na&apos;.repeat(2.9) // &quot;nana&quot;</span><br></pre></td></tr></table></figure></p><p>如果repeat的参数是负数或者Infinity，会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;na&apos;.repeat(Infinity)</span><br><span class="line">// RangeError</span><br><span class="line">&apos;na&apos;.repeat(-1)</span><br><span class="line">// RangeError</span><br></pre></td></tr></table></figure></p><p>如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0<br>参数NaN等同于 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;na&apos;.repeat(-0.9) // &quot;&quot;</span><br></pre></td></tr></table></figure></p><p>参数是字符串，则会先转换成数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot;</span><br><span class="line">&apos;na&apos;.repeat(&apos;3&apos;) // &quot;nanana&quot;</span><br></pre></td></tr></table></figure></p><h3 id="padStart-，padEnd"><a href="#padStart-，padEnd" class="headerlink" title="padStart()，padEnd()"></a>padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line"></span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure></p><p>上面代码中，padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p><p>如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;xxx&apos;.padStart(2, &apos;ab&apos;) // &apos;xxx&apos;</span><br><span class="line">&apos;xxx&apos;.padEnd(2, &apos;ab&apos;) // &apos;xxx&apos;</span><br></pre></td></tr></table></figure></p><p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;abc&apos;.padStart(10, &apos;0123456789&apos;)</span><br><span class="line">// &apos;0123456abc&apos;</span><br></pre></td></tr></table></figure></p><p>如果省略第二个参数，默认使用空格补全长度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(4) // &apos;   x&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4) // &apos;x   &apos;</span><br></pre></td></tr></table></figure></p><p>padStart()的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;1&apos;.padStart(10, &apos;0&apos;) // &quot;0000000001&quot;</span><br><span class="line">&apos;12&apos;.padStart(10, &apos;0&apos;) // &quot;0000000012&quot;</span><br><span class="line">&apos;123456&apos;.padStart(10, &apos;0&apos;) // &quot;0000123456&quot;</span><br></pre></td></tr></table></figure></p><p>另一个用途是提示字符串格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-MM-12&quot;</span><br><span class="line">&apos;09-12&apos;.padStart(10, &apos;YYYY-MM-DD&apos;) // &quot;YYYY-09-12&quot;</span><br></pre></td></tr></table></figure><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>传统的输出模板常为字符串拼接，这种写法相当繁琐和不简洁，ES6 引入了模板字符串解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#result&apos;).append(`</span><br><span class="line">  There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items</span><br><span class="line">   in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt;</span><br><span class="line">  are on sale!</span><br><span class="line">`);</span><br></pre></td></tr></table></figure></p><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量,模板字符串中嵌入变量，需要将变量名写在${}之中。</p><p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure><p>使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure><p>所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#list&apos;).html(`</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure></ul></p><p>${}大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`</span><br><span class="line">// &quot;1 + 4 = 5&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123;x: 1, y: 2&#125;;</span><br><span class="line">`$&#123;obj.x + obj.y&#125;`</span><br><span class="line">// &quot;3&quot;</span><br></pre></td></tr></table></figure></p><p>模板字符串之中还能调用函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  return &quot;Hello World&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`foo $&#123;fn()&#125; bar`</span><br><span class="line">// foo Hello World bar</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符串的遍历器接口&quot;&gt;&lt;a href=&quot;#字符串的遍历器接口&quot; class=&quot;headerlink&quot; title=&quot;字符串的遍历器接口&quot;&gt;&lt;/a&gt;字符串的遍历器接口&lt;/h3&gt;&lt;p&gt;ES6 为字符串添加了遍历器接口（Iterator接口），使得字符串可以被for…of循环遍历&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;for (let num of &amp;apos;foo&amp;apos;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;quot;f&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;quot;o&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// &amp;quot;o&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;includes-startsWith-endsWith&quot;&gt;&lt;a href=&quot;#includes-startsWith-endsWith&quot; class=&quot;headerlink&quot; title=&quot;includes(), startsWith(), endsWith()&quot;&gt;&lt;/a&gt;includes(), startsWith(), endsWith()&lt;/h3&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>es6基础之变量的解构赋值</title>
    <link href="http://yoursite.com/2019/03/08/es6-1/"/>
    <id>http://yoursite.com/2019/03/08/es6-1/</id>
    <published>2019-03-08T05:50:19.000Z</published>
    <updated>2019-03-11T02:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下<br><a href="http://es6.ruanyifeng.com/#README" target="_blank" rel="noopener">传送门</a></p><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><p>概念：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值<br>基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = [1, 2, 3];</span><br></pre></td></tr></table></figure></p><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值,也就是说，只要两边的模式相同，左边的变量就会对应赋为右边的值<br><a id="more"></a><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let [a, [[b], c]] = [1, [[2], 3]];</span><br><span class="line">a // 1</span><br><span class="line">b// 2</span><br><span class="line">c // 3</span><br><span class="line"></span><br><span class="line">let [ , , str] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">str // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">let [fir, ...sce] = [1, 2, 3, 4];</span><br><span class="line">fir // 1</span><br><span class="line">sce // [2, 3, 4]</span><br></pre></td></tr></table></figure></p><p>如果解构不成功，变量的值就等于undefined。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [foo] = [];</span><br><span class="line">let [bar, foo] = [1];</span><br></pre></td></tr></table></figure></p><p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p><p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let [foo = true] = [];</span><br><span class="line">foo // true</span><br><span class="line"></span><br><span class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br><span class="line">let [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=&apos;b&apos;</span><br></pre></td></tr></table></figure></p><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值</p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure><p>对象解构赋值时变量必须与属性同名，才能取到正确的值<br>数组的元素是按次序排列的，变量的取值由它的位置决定。而对象不用受位置限制</p><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p><p>如果变量名与属性名不一致，必须写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line"></span><br><span class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</span><br><span class="line">let &#123; first: f, last: l &#125; = obj;</span><br><span class="line">f // &apos;hello&apos;</span><br><span class="line">l // &apos;world&apos;</span><br></pre></td></tr></table></figure></p><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure></p><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p><h3 id="解构赋值的用途"><a href="#解构赋值的用途" class="headerlink" title="解构赋值的用途"></a>解构赋值的用途</h3><ol><li><p>交换变量的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = 1;</span><br><span class="line">let y = 2;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];//x：2 y:1</span><br></pre></td></tr></table></figure></li><li><p>函数返回多个值<br>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function example() &#123;</span><br><span class="line">  return [1, 2, 3];</span><br><span class="line">&#125;</span><br><span class="line">let [a, b, c] = example();</span><br><span class="line"></span><br><span class="line">// 返回一个对象</span><br><span class="line"></span><br><span class="line">function example() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">let &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></li><li><p>函数参数的定义<br>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 参数是一组有次序的值</span><br><span class="line">function f([x, y, z]) &#123; ... &#125;</span><br><span class="line">f([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 参数是一组无次序的值</span><br><span class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</span><br><span class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</span><br></pre></td></tr></table></figure></li><li><p>提取 JSON 数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: 42,</span><br><span class="line">  status: &quot;OK&quot;,</span><br><span class="line">  data: [867, 5309]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, status, data: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.log(id, status, number);</span><br><span class="line">// 42, &quot;OK&quot;, [867, 5309]</span><br></pre></td></tr></table></figure></li></ol><p>上面代码可以快速提取 JSON 数据的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文源自阮老师的ES6入门教程，为了之后方便自己随时查看，将常用的es6部分整理了一下&lt;br&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#README&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;数组的解构赋值&quot;&gt;&lt;a href=&quot;#数组的解构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h3&gt;&lt;p&gt;概念：ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值&lt;br&gt;基本用法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let [a, b, c] = [1, 2, 3];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值,也就是说，只要两边的模式相同，左边的变量就会对应赋为右边的值&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="es6" scheme="http://yoursite.com/categories/es6/"/>
    
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>hexo文章中插入图片问题</title>
    <link href="http://yoursite.com/2019/03/04/img/"/>
    <id>http://yoursite.com/2019/03/04/img/</id>
    <published>2019-03-04T06:26:42.000Z</published>
    <updated>2019-03-04T09:45:47.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo内本地图片直接引入无法显示问题"><a href="#hexo内本地图片直接引入无法显示问题" class="headerlink" title="hexo内本地图片直接引入无法显示问题"></a>hexo内本地图片直接引入无法显示问题</h3><ol><li>把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true</li><li>在根目录下输入npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件</li><li>再运行hexo new “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹</li><li>最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片即可</li></ol><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//![你想输入的替代文字](xxxx/图片名.jpg)</span><br></pre></td></tr></table></figure></p><ol start="5"><li>hexo d 上传后就能看到图片了</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hexo内本地图片直接引入无法显示问题&quot;&gt;&lt;a href=&quot;#hexo内本地图片直接引入无法显示问题&quot; class=&quot;headerlink&quot; title=&quot;hexo内本地图片直接引入无法显示问题&quot;&gt;&lt;/a&gt;hexo内本地图片直接引入无法显示问题&lt;/h3&gt;&lt;ol&gt;

      
    
    </summary>
    
      <category term="主题相关" scheme="http://yoursite.com/categories/%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo添加live2d看板动画</title>
    <link href="http://yoursite.com/2019/03/04/live2d/"/>
    <id>http://yoursite.com/2019/03/04/live2d/</id>
    <published>2019-03-04T05:53:58.000Z</published>
    <updated>2019-03-04T09:50:45.922Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo的next主题添加看板动画"><a href="#hexo的next主题添加看板动画" class="headerlink" title="hexo的next主题添加看板动画"></a>hexo的next主题添加看板动画</h3><ol><li>git定位到根目录文件，并输入以下命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol start="2"><li><p>下载各种模型：npm install + 模型名 (npm install live2d-widget-model-shizuku)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">live2d-widget-model-chitose</span><br><span class="line">live2d-widget-model-epsilon2_1</span><br><span class="line">live2d-widget-model-gf</span><br><span class="line"></span><br><span class="line">live2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)</span><br><span class="line"></span><br><span class="line">live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)</span><br><span class="line">live2d-widget-model-haruto</span><br><span class="line">live2d-widget-model-hibiki</span><br><span class="line">live2d-widget-model-hijiki</span><br><span class="line">live2d-widget-model-izumi</span><br><span class="line">live2d-widget-model-koharu</span><br><span class="line">live2d-widget-model-miku</span><br><span class="line">live2d-widget-model-ni-j</span><br><span class="line">live2d-widget-model-nico</span><br><span class="line">live2d-widget-model-niet</span><br></pre></td></tr></table></figure></li><li><p>此时再去 node_moduels目录下，可以看到有如下文件夹，这些都是动画主配置<br><img src="/2019/03/04/live2d/01.png" alt="zi"></p></li><li>在Hexo根目录中新建文件夹live2d_models，然后在node_modules文件夹中找到刚刚下载的live2d模型，将其复制到live2d_models中</li><li><p>hexo的配置文件_config.yml中添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#2d</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  scriptFrom: local</span><br><span class="line">  pluginRootPath: live2dw/</span><br><span class="line">  pluginJsPath: lib/</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  tagMode: false</span><br><span class="line">  debug: false</span><br><span class="line">  model:</span><br><span class="line">    use: live2d-widget-model-shizuku</span><br><span class="line">  display:</span><br><span class="line">    position: left</span><br><span class="line">    width: 120</span><br><span class="line">    height: 240</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br></pre></td></tr></table></figure></li><li><p>配置博客站点配置文件，_config.yml将里面的use:换成下载的模型名称</p></li><li><p>hexo d上传后就会在右下角出现live2d动画了</p></li><li><p>取消看板动画<br>直接运行npm uninstall hexo-helper-live2d<br>去掉站点_config.yml下的配置信息即可</p></li></ol><h3 id="添加live2d直接引入版（这个是github上人家的api，也许会在哪天失效）"><a href="#添加live2d直接引入版（这个是github上人家的api，也许会在哪天失效）" class="headerlink" title="添加live2d直接引入版（这个是github上人家的api，也许会在哪天失效）"></a>添加live2d直接引入版（这个是github上人家的api，也许会在哪天失效）</h3><p>不想配置的话，直接在next/layout/_layout.swig(生成主页面的文件)中引入下面文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//将代码加入&lt;head&gt;或&lt;body&gt;，就可以看到效果了</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css&quot;/&gt;</span><br><span class="line">&lt;script src=&quot;https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>此配置来自github上大佬的资源，<a href="https://github.com/stevenjoezhang/live2d-widget" target="_blank" rel="noopener">附上大佬的github地址</a><br>这是人家的一个api，也许哪天挂了呢？如果想一直使用要拷贝到自己的服务器中，并搭建php环境，<a href="https://github.com/fghrsh/live2d_api" target="_blank" rel="noopener">api的github地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hexo的next主题添加看板动画&quot;&gt;&lt;a href=&quot;#hexo的next主题添加看板动画&quot; class=&quot;headerlink&quot; title=&quot;hexo的next主题添加看板动画&quot;&gt;&lt;/a&gt;hexo的next主题添加看板动画&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;git定位到根目录文件，并输入以下命令&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install --save hexo-helper-live2d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="主题相关" scheme="http://yoursite.com/categories/%E4%B8%BB%E9%A2%98%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>vuex的相关使用</title>
    <link href="http://yoursite.com/2019/03/01/vuex/"/>
    <id>http://yoursite.com/2019/03/01/vuex/</id>
    <published>2019-03-01T08:13:25.000Z</published>
    <updated>2019-03-01T09:24:30.035Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day1/1.jpg" alt="avatar"></p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>单独建一个store文件夹，用来管理store的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import Vuex from &apos;vuex&apos;</span><br><span class="line">import &apos;es6-promise/auto&apos;</span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><a id="more"></a><ol><li>store（仓库）：“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)<br>store 中的状态不能直接修改，改变 store 中的状态的唯一途径就是显式地提交 (commit) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const state = &#123;</span><br><span class="line">  uuid: &apos;&apos;,</span><br><span class="line">  user: &#123;&#125;,</span><br><span class="line">  qrCode:&apos;&apos;,</span><br><span class="line">  qrCodeUser:&#123;&#125;,</span><br><span class="line">  prizeQrCode:&apos;&apos;,</span><br><span class="line">  prizeQrCodeUser:&#123;&#125;,</span><br><span class="line">  errorMsg:&apos;&apos;,</span><br><span class="line">&#125;</span><br><span class="line">$store.commit(&apos;setQrCode&apos;,&apos;e1dddec9&apos;)//setQrCode是要修改的state内的状态，e1dddec9是修改为的数据，可以是一个对象</span><br></pre></td></tr></table></figure></li></ol><p>2.getter（可以认为是 store 的计算属性）：就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算<br>Getter 接受 state 作为其第一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const getters = &#123;</span><br><span class="line">  // 将数据从cache中取出</span><br><span class="line">  getCache: function (state) &#123;</span><br><span class="line">    return function (key) &#123;</span><br><span class="line">      var cache_data = localStorage.getItem(key)</span><br><span class="line">      if (!cache_data) &#123;</span><br><span class="line">        return null</span><br><span class="line">      &#125;</span><br><span class="line">      // var data = JSON.parse(Base64.decode(cache_data))</span><br><span class="line">      var data = JSON.parse(cache_data)</span><br><span class="line">      if (data.timeout === 0 || data.timeout &gt; (new Date()).getTime()) &#123;</span><br><span class="line">        return data.data</span><br><span class="line">      &#125;</span><br><span class="line">      localStorage.removeItem(key)</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getUUID: function () &#123;</span><br><span class="line">    return state.uuid</span><br><span class="line">  &#125;,</span><br><span class="line">  getAdminUserInfo: function () &#123;</span><br><span class="line">    return state.user</span><br><span class="line">  &#125;,</span><br><span class="line">  getQrCode:function () &#123;</span><br><span class="line">    return state.qrCode</span><br><span class="line">  &#125;,</span><br><span class="line">  getQrCodeUserInfo:function () &#123;</span><br><span class="line">  return state.qrCodeUser</span><br><span class="line">  &#125;,</span><br><span class="line">getPrizeQrCode:function () &#123;</span><br><span class="line">return state.prizeQrCode</span><br><span class="line">&#125;,</span><br><span class="line">getPrizeQrCodeUserInfo:function () &#123;</span><br><span class="line">return state.prizeQrCodeUser</span><br><span class="line">&#125;,</span><br><span class="line">  getErrMsg:function () &#123;</span><br><span class="line">  return state.errorMsg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在任意组件的计算属性中可以获取getters内函数的返回值<br>如：获取上面计算属性中的UID<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">uid:function () &#123;</span><br><span class="line">return this.$store.getters[&apos;getUUID&apos;];</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><p>3.Mutation<br>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//第一个参数为state状态对象，第二个参数Payload载荷（也就是要修改为的数据）</span><br><span class="line">const mutations = &#123;</span><br><span class="line">  // 将数据存储到cache中</span><br><span class="line">  setCache: function (state, data) &#123;</span><br><span class="line">    if (data.timeout === undefined) &#123;</span><br><span class="line">      data.timeout = 30 * 24 * 3600 * 1000</span><br><span class="line">    &#125;</span><br><span class="line">    var obj = &#123;</span><br><span class="line">      data: data.value,</span><br><span class="line">      timeout: data.timeout + (new Date()).getTime()</span><br><span class="line">    &#125;</span><br><span class="line">    // var cache = Base64.encode(JSON.stringify(obj));</span><br><span class="line">    var cache = JSON.stringify(obj)</span><br><span class="line">    localStorage.setItem(data.key, cache)</span><br><span class="line">  &#125;,</span><br><span class="line">  clearCache: function (state, key) &#123;</span><br><span class="line">    localStorage.removeItem(key)</span><br><span class="line">  &#125;,</span><br><span class="line">  setAdminUserInfo (state, data) &#123;</span><br><span class="line">    state.user = data</span><br><span class="line">  &#125;,</span><br><span class="line">  setQrCodeUserInfo(state,data)&#123;</span><br><span class="line">  state.qrCodeUser = data;</span><br><span class="line">  &#125;,</span><br><span class="line">  setQrCode(state,data)&#123;</span><br><span class="line">  state.qrCode = data;</span><br><span class="line">  &#125;,</span><br><span class="line">setPrizeQrCodeUserInfo(state,data)&#123;</span><br><span class="line">state.prizeQrCodeUser = data;</span><br><span class="line">&#125;,</span><br><span class="line">setPrizeQrCode(state,data)&#123;</span><br><span class="line">state.prizeQrCode = data;</span><br><span class="line">&#125;,</span><br><span class="line">  setErrMsg(state,data)&#123;</span><br><span class="line">  state.errorMsg = data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在组件中提交 Mutation（提交载荷）<br>在组件中使用 this.$store.commit(‘xxx’) 提交 mutation<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">getQrcodeInfo:function (code) &#123;</span><br><span class="line">          let self = this;</span><br><span class="line">this.$http(&#123;</span><br><span class="line">methods:&apos;get&apos;,</span><br><span class="line">url:&apos;/mfw/xiaoliwu/backend/Login/showCodeInfo&apos;,</span><br><span class="line">params:&#123;</span><br><span class="line">uid:this.uid,</span><br><span class="line">code:code</span><br><span class="line">&#125;</span><br><span class="line">&#125;).then(res=&gt;&#123;</span><br><span class="line">console.log(res)</span><br><span class="line">if(res.data.code === 0)&#123;</span><br><span class="line">self.$store.commit(&apos;setQrCodeUserInfo&apos;,res.data.data)//此处就是提交上面mutation内的setQrCodeUserInfo函数，这个函数的第二个参数就是上面的data</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">path:&apos;/convert&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">self.$vux.alert.show(&#123;</span><br><span class="line">title: &apos;&apos;,</span><br><span class="line">content: res.data.msg,</span><br><span class="line">buttonText:&apos;知道了&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><ol start="4"><li>Action<br>Action 类似于 mutation，不同在于：</li></ol><p>Action 提交的是 mutation，而不是直接变更状态。<br>Action 可以包含任意异步操作。</p><ol start="5"><li>Module<br>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿</li></ol><p>为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a // -&gt; moduleA 的状态</span><br><span class="line">store.state.b // -&gt; moduleB 的状态</span><br></pre></td></tr></table></figure></p><p>模块的局部状态<br>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  state: &#123; count: 0 &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      // 这里的 `state` 对象是模块的局部状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      return state.count * 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样，对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      if ((state.count + rootState.count) % 2 === 1) &#123;</span><br><span class="line">        commit(&apos;increment&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const moduleA = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      return state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>将上面的以常量形式声明的各个核心导出，就可以在任意组件中调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state, getters, mutations, actions</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day1/1.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h3&gt;&lt;p&gt;单独建一个store文件夹，用来管理store的状态&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import Vue from &amp;apos;vue&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import Vuex from &amp;apos;vuex&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;apos;es6-promise/auto&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import axios from &amp;apos;axios&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.use(Vuex)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;核心概念&quot;&gt;&lt;a href=&quot;#核心概念&quot; class=&quot;headerlink&quot; title=&quot;核心概念&quot;&gt;&lt;/a&gt;核心概念&lt;/h3&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
  </entry>
  
  <entry>
    <title>微信jssdk的接入（分享及扫码功能）</title>
    <link href="http://yoursite.com/2019/03/01/sdk/"/>
    <id>http://yoursite.com/2019/03/01/sdk/</id>
    <published>2019-03-01T07:43:06.000Z</published>
    <updated>2019-03-01T08:17:18.886Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day1/1.jpg" alt="avatar"></p><h3 id="vue中使用（vux版）"><a href="#vue中使用（vux版）" class="headerlink" title="vue中使用（vux版）"></a>vue中使用（vux版）</h3><h4 id="微信扫一扫功能"><a href="#微信扫一扫功能" class="headerlink" title="微信扫一扫功能"></a>微信扫一扫功能</h4><p>分享接口只有认证公众号才能使用，域名必须备案且在微信后台设置。<br><a id="more"></a><br>先确认已经满足使用jssdk的要求再进行开发。<br>1.引入vux类库<br>2.在 main.js 中全局引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; WechatPlugin &#125; from &apos;vux&apos;</span><br><span class="line">Vue.use(WechatPlugin)</span><br><span class="line"></span><br><span class="line">console.log(Vue.wechat) // 可以直接访问 wx 对象。</span><br></pre></td></tr></table></figure></p><p>3.全局引入后就可以在任意组件内调用了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">self.$wechat.scanQRCode(&#123;</span><br><span class="line">needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，</span><br><span class="line">scanType: [&quot;qrCode&quot;], // 可以指定扫二维码还是一维码，默认二者都有</span><br><span class="line">success: function (res) &#123;</span><br><span class="line">self.$vux.loading.hide();</span><br><span class="line">var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果</span><br><span class="line">if (result)&#123;</span><br><span class="line">self.$store.commit(&apos;setQrCode&apos;,result);</span><br><span class="line">self.getQrcodeInfo(result)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">self.$vux.alert.show(&#123;</span><br><span class="line">content:&apos;未识别的兑换码&apos;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>附录：<a href="https://mp.weixin.qq.com/wiki?" target="_blank" rel="noopener">微信js-sdk说明文档</a></p><h3 id="jquery中使用sdk"><a href="#jquery中使用sdk" class="headerlink" title="jquery中使用sdk"></a>jquery中使用sdk</h3><p>1.在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.4.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.4.0.js</a></p><p>2.jssdk的签名权限,这个权限是由后台提供的,前端只需要把签名权限注入到wx.config中就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//初始化jssdk</span><br><span class="line">    var init = function(data)&#123;</span><br><span class="line">        //通过config接口注入权限验证配置</span><br><span class="line">        wx.config(&#123;</span><br><span class="line">            debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。</span><br><span class="line">            appId: data.app_id, // 必填，公众号的唯一标识</span><br><span class="line">            timestamp: data.timestamp, // 必填，生成签名的时间戳</span><br><span class="line">            nonceStr: data.nonceStr, // 必填，生成签名的随机串</span><br><span class="line">            signature: data.signature,// 必填，签名，见附录1</span><br><span class="line">            jsApiList: [&apos;onMenuShareTimeline&apos;,&apos;onMenuShareAppMessage&apos;] // 必填，需要使用的JS接口列表</span><br><span class="line">        &#125;);</span><br><span class="line">        //通过ready接口处理成功验证</span><br><span class="line">        wx.ready(function()&#123;</span><br><span class="line">            //分享到朋友圈</span><br><span class="line">            </span><br><span class="line">//  var local_url = $.getStorge(&apos;auth_url&apos;);</span><br><span class="line">//  if(!local_url)&#123;</span><br><span class="line">//  local_url = window.location.href;</span><br><span class="line">//  &#125;</span><br><span class="line">    var local_url = window.location.href;</span><br><span class="line">           </span><br><span class="line">            console.log(local_url);</span><br><span class="line">            wx.onMenuShareTimeline(&#123;</span><br><span class="line">    title: desc+&apos;--&apos;+title, // 分享标题</span><br><span class="line">    link: local_url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span><br><span class="line">    imgUrl: &apos;http://jssdk.cloud-cy.com/wechatShopServer/&apos;+logo, // 分享图标</span><br><span class="line">    success: function () &#123; </span><br><span class="line">        // 用户确认分享后执行的回调函数</span><br><span class="line">    &#125;,</span><br><span class="line">    cancel: function () &#123; </span><br><span class="line">        // 用户取消分享后执行的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">//分享给朋友</span><br><span class="line">wx.onMenuShareAppMessage(&#123;</span><br><span class="line">    title: title, // 分享标题</span><br><span class="line">    desc: desc, // 分享描述</span><br><span class="line">    link: local_url, // 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span><br><span class="line">    imgUrl: &apos;http://jssdk.cloud-cy.com/wechatShopServer/&apos;+logo, // 分享图标</span><br><span class="line">    type: &apos;link&apos;, // 分享类型,music、video或link，不填默认为link</span><br><span class="line">    dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空</span><br><span class="line">    success: function () &#123; </span><br><span class="line">        // 用户确认分享后执行的回调函数</span><br><span class="line">    &#125;,</span><br><span class="line">    cancel: function () &#123; </span><br><span class="line">        // 用户取消分享后执行的回调函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">//获取jssdk配置</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">        type:&quot;get&quot;,</span><br><span class="line">        url:web+&quot;/Jssdk&quot;,</span><br><span class="line">        data:&#123;</span><br><span class="line">        url:window.location.href,</span><br><span class="line">        url_code:account</span><br><span class="line">        &#125;,</span><br><span class="line">        dataType:&quot;json&quot;,</span><br><span class="line">        success:function(data,textStatus)&#123;console.log(data);</span><br><span class="line">            if(data.code==200)&#123;</span><br><span class="line">                init(data.data);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">//              alert(&quot;连接失败，请稍后再试或联系管理员&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day1/1.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;vue中使用（vux版）&quot;&gt;&lt;a href=&quot;#vue中使用（vux版）&quot; class=&quot;headerlink&quot; title=&quot;vue中使用（vux版）&quot;&gt;&lt;/a&gt;vue中使用（vux版）&lt;/h3&gt;&lt;h4 id=&quot;微信扫一扫功能&quot;&gt;&lt;a href=&quot;#微信扫一扫功能&quot; class=&quot;headerlink&quot; title=&quot;微信扫一扫功能&quot;&gt;&lt;/a&gt;微信扫一扫功能&lt;/h4&gt;&lt;p&gt;分享接口只有认证公众号才能使用，域名必须备案且在微信后台设置。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue的类库vux安装</title>
    <link href="http://yoursite.com/2019/03/01/day5/"/>
    <id>http://yoursite.com/2019/03/01/day5/</id>
    <published>2019-03-01T07:14:55.000Z</published>
    <updated>2019-03-20T04:13:21.717Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day1/1.jpg" alt="avatar"></p><p>##cli环境中安装vux类库</p><pre><code>1. npm install vux --save2. 安装vux-loader （这个vux文档似乎没介绍，当初没安装结果报了一堆错误） <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vux-loader --save-dev</span><br></pre></td></tr></table></figure>3. 安装less-loader  （这个是用以正确编译less源码，否则会出现 &apos; Cannot GET / &apos;）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install less less-loader --save-dev</span><br></pre></td></tr></table></figure>4. vux2必须配合vux-loader使用, 请在build/webpack.base.conf.js里参照如下代码进行配置：</code></pre><a id="more"></a><pre><code>const vuxLoader = require(&apos;vux-loader&apos;)const webpackConfig = originalConfig 将原来的 module.exports 代码赋值给变量 webpackConfig (将原文件的module.exports改为let webpackConfig) 5.在文件最后一行复制下面代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = vuxLoader.merge(webpackConfig, &#123;</span><br><span class="line">  plugins: [&apos;vux-ui&apos;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>6. 在入口文件全局引入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import &#123; XButton &#125; from &apos;vux&apos;</span><br></pre></td></tr></table></figure>例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;x-button&apos;, XButton)</span><br></pre></td></tr></table></figure>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;x-button&gt;&lt;/x-button&gt;</span><br></pre></td></tr></table></figure>vux样式改变，可以在APP.vue中用样式覆盖，在组件内用scoped无法覆盖</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day1/1.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;p&gt;##cli环境中安装vux类库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. npm install vux --save

2. 安装vux-loader （这个vux文档似乎没介绍，当初没安装结果报了一堆错误） 
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install vux-loader --save-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

3. 安装less-loader  （这个是用以正确编译less源码，否则会出现 &amp;apos; Cannot GET / &amp;apos;）
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install less less-loader --save-dev&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

4. vux2必须配合vux-loader使用, 请在build/webpack.base.conf.js里参照如下代码进行配置：
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序基础</title>
    <link href="http://yoursite.com/2019/02/28/weChat/"/>
    <id>http://yoursite.com/2019/02/28/weChat/</id>
    <published>2019-02-28T07:16:13.000Z</published>
    <updated>2019-03-04T06:03:50.110Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day3/wechat.jpg" alt="avatar"></p><h2 id="微信小程序相关及一些小坑"><a href="#微信小程序相关及一些小坑" class="headerlink" title="微信小程序相关及一些小坑"></a>微信小程序相关及一些小坑</h2><h3 id="1-页面滑动"><a href="#1-页面滑动" class="headerlink" title="1.页面滑动"></a>1.页面滑动</h3><p>小程序内容超出父盒子，或者页面超出屏幕都不会出现滚动条滑动，如需要滑动，要使用scroll-view组件包裹着要滑动的区域<br><a href="https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html" target="_blank" rel="noopener">scroll-view</a>相关配置属性<br><a id="more"></a></p><h4 id="scroll-view相关"><a href="#scroll-view相关" class="headerlink" title="scroll-view相关"></a>scroll-view相关</h4><ol><li>scroll-view生效需要设置高度，如果没有设置高度，滑动效果不生效</li><li>去除scroll-view默认滚动条<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">::-webkit-scrollbar&#123;</span><br><span class="line"></span><br><span class="line">width: 0;</span><br><span class="line"></span><br><span class="line">height: 0;</span><br><span class="line"></span><br><span class="line">color: transparent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-闭包问题"><a href="#2-闭包问题" class="headerlink" title="2.闭包问题"></a>2.闭包问题</h3><p>请求后台api中的success函数实际是一个闭包 ， 无法直接通过this来设置setData;<br>解决方案：<br>1.将当前对象赋给一个新对象：let that = this<br>2.使用箭头函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">  console.log(options.uselogid)</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: util.Api.getUserPrizeInfo,</span><br><span class="line">    method: &apos;get&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      openid: app.globalData.openid,</span><br><span class="line">      user_log_id: options.uselogid</span><br><span class="line">    &#125;,</span><br><span class="line">    success: (res) =&gt; &#123;</span><br><span class="line">      // console.log(res.data)</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        cardData: res.data.data,</span><br><span class="line">        qrCode: res.data.data.qrCodeUrl,</span><br><span class="line">        uselogid: options.uselogid,</span><br><span class="line">        status: res.data.data.status</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(this.data.status)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-背景图片问题"><a href="#3-背景图片问题" class="headerlink" title="3.背景图片问题"></a>3.背景图片问题</h3><p>  小程序中的背景图片写在wxss预览时无法显现<br>  解决方案：<br>  1.将图片转为base64格式，才能在wxss内设置<br>  2.写行内样式，图片用网络图片，本地图片无法预览</p><h3 id="4-路由"><a href="#4-路由" class="headerlink" title="4.路由"></a>4.路由</h3><p> 1.使用navigator标签导航，注意url地址不能带文件后缀<br> 2.在js文件内注册事件跳转<br> wx.navigateTo跳转保留当前页面，也就是说会有返回箭头<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">      url: &apos;/pages/cardDetial/cardDetial?uselogid=&apos; + e.currentTarget.dataset.uselogid,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>wx.redirectTo跳转 关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.redirectTo(&#123;</span><br><span class="line">      url: &apos;/pages/superGift/superGift&apos;,</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="5-页面间传值"><a href="#5-页面间传值" class="headerlink" title="5.页面间传值"></a>5.页面间传值</h3><p>传值:和web页面差不多，也是在url地址后面拼接参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wx.navigateTo(&#123;</span><br><span class="line">        url: &apos;/pages/cardDetial/cardDetial?uselogid=&apos; + e.currentTarget.dataset.uselogid,</span><br><span class="line">      &#125;)</span><br></pre></td></tr></table></figure></p><p>接收：直接在生命周期onLoad里用参数接收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">  console.log(options.uselogid)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p><h3 id="6-无法使用外部字体图标"><a href="#6-无法使用外部字体图标" class="headerlink" title="6.无法使用外部字体图标"></a>6.无法使用外部字体图标</h3><p>大部分情况下直接下载iconfont的压缩包，将其内的iconfont.css文件复制到一个新的wxss文件内，然后在app.wxss文件内全局引入@import “/lib/style/iconfont.wxss”;就可以在任意文件中使用了<br>如果出现无法使用的情况，试试下面方法：<br>1，下载font-awesome字体包</p><p>2，打开Transfonter网站，上传字体iconfont.ttf，选择base64编码</p><p>3，convert完毕后点击下载，下载得到的包中有stylesheet.css文件，打开并对照font-awesome.css中的内容进行合并base64部分，加入到微信小程序的xxx.wxss文件中进行使用</p><pre><code>&lt;text class=&quot;iconfont icon-xxxx&quot;&gt;&lt;/text&gt;</code></pre><h3 id="7-setData修改数组或对象"><a href="#7-setData修改数组或对象" class="headerlink" title="7.setData修改数组或对象"></a>7.setData修改数组或对象</h3><p>setData无法直接修改引用类型的数据，需要字符串拼接的方式保存到变量中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var closeShow = &quot;redPacket.myClosePackect&quot;</span><br><span class="line">self.setData(&#123;</span><br><span class="line">            </span><br><span class="line">             [closeShow]: false,</span><br><span class="line">             </span><br><span class="line">           &#125;)</span><br></pre></td></tr></table></figure></p><h3 id="8-textarea注意事项"><a href="#8-textarea注意事项" class="headerlink" title="8.textarea注意事项"></a>8.textarea注意事项</h3><p>1.bug: 微信版本 6.3.30，textarea 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误。<br>2.tip: textarea 的 blur 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 form 的 bindsubmit。<br>3.tip: 不建议在多行文本上对用户的输入进行修改，所以 textarea 的 bindinput 处理函数并不会将返回值反映到 textarea 上。<br>4.tip: textarea 组件是由客户端创建的原生组件，它的层级是最高的，不能通过 z-index 控制层级。<br>5.tip: 请勿在 scroll-view、swiper、picker-view、movable-view 中使用 textarea 组件。<br>6.tip: css 动画对 textarea 组件无效。</p><h3 id="9-原生组件无法被覆盖的问题"><a href="#9-原生组件无法被覆盖的问题" class="headerlink" title="9.原生组件无法被覆盖的问题"></a>9.原生组件无法被覆盖的问题</h3><p>map、video、canvas、camera 等原生组件上不可被标签覆盖，如果需要覆盖，要使用cover-view标签 且只支持嵌套cover-view、cover-image</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/day3/wechat.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;微信小程序相关及一些小坑&quot;&gt;&lt;a href=&quot;#微信小程序相关及一些小坑&quot; class=&quot;headerlink&quot; title=&quot;微信小程序相关及一些小坑&quot;&gt;&lt;/a&gt;微信小程序相关及一些小坑&lt;/h2&gt;&lt;h3 id=&quot;1-页面滑动&quot;&gt;&lt;a href=&quot;#1-页面滑动&quot; class=&quot;headerlink&quot; title=&quot;1.页面滑动&quot;&gt;&lt;/a&gt;1.页面滑动&lt;/h3&gt;&lt;p&gt;小程序内容超出父盒子，或者页面超出屏幕都不会出现滚动条滑动，如需要滑动，要使用scroll-view组件包裹着要滑动的区域&lt;br&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scroll-view&lt;/a&gt;相关配置属性&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="weChat" scheme="http://yoursite.com/categories/weChat/"/>
    
    
  </entry>
  
  <entry>
    <title>将博客搬至CSDN</title>
    <link href="http://yoursite.com/2019/02/26/blogchange/"/>
    <id>http://yoursite.com/2019/02/26/blogchange/</id>
    <published>2019-02-26T06:10:08.000Z</published>
    <updated>2019-03-01T06:56:08.447Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/public/02.jpg" alt="avatar"></p><h3 id="搬家通知地址"><a href="#搬家通知地址" class="headerlink" title="搬家通知地址"></a>搬家通知地址</h3><p>个人博客地址已搬家到CSDN，希望大家多多支持</p><a id="more"></a><p>最近利用hexo搭了一个博客主页，之前都是混掘金，但感觉掘金上的人越来越少了，是时候踏入下一个江湖啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/langhuonan/wechat/master/mdImages/public/02.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;搬家通知地址&quot;&gt;&lt;a href=&quot;#搬家通知地址&quot; class=&quot;headerlink&quot; title=&quot;搬家通知地址&quot;&gt;&lt;/a&gt;搬家通知地址&lt;/h3&gt;&lt;p&gt;个人博客地址已搬家到CSDN，希望大家多多支持&lt;/p&gt;
    
    </summary>
    
    
      <category term="搬家" scheme="http://yoursite.com/tags/%E6%90%AC%E5%AE%B6/"/>
    
  </entry>
  
</feed>
